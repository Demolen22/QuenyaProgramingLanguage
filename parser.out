Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CLOSE_CURL_BRACKET
    CLOSE_SQ_BRACKET
    COMMENT
    ITERABLE_LOOP
    LIST
    NULL
    N_EQUAL
    OPEN_CURL_BRACKET
    OPEN_SQ_BRACKET
    PRINT

Grammar

Rule 0     S' -> program_decl
Rule 1     program_decl -> PROGRAM block
Rule 2     block -> BEGIN block_body END
Rule 3     block_body -> lines
Rule 4     block_body -> loop
Rule 5     block_body -> if_stat
Rule 6     block_body -> func_decl
Rule 7     lines -> lines line
Rule 8     lines -> line
Rule 9     line -> line_body ENDLINE
Rule 10    line_body -> var_decl
Rule 11    line_body -> func_call
Rule 12    line_body -> var_assign
Rule 13    loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET block
Rule 14    func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN block_body RETURN return_val
Rule 15    return_val -> ID
Rule 16    return_val -> expr
Rule 17    return_val -> func_call
Rule 18    var_decl -> type ID ASSIGN value
Rule 19    var_assign -> ID ASSIGN value
Rule 20    value -> NUMBER
Rule 21    value -> STRING_EXPR
Rule 22    value -> func_call
Rule 23    value -> expr
Rule 24    values -> values value
Rule 25    values -> value
Rule 26    type -> INT
Rule 27    type -> STRING
Rule 28    func_call -> ID OPEN_BRACKET values CLOSE_BRACKET
Rule 29    arg -> type ID
Rule 30    args -> args arg
Rule 31    args -> arg
Rule 32    if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN block_body end_if
Rule 33    end_if -> END
Rule 34    end_if -> else_stat
Rule 35    else_stat -> ELSE THEN block_body END
Rule 36    expr -> expr oper_add comp
Rule 37    expr -> comp
Rule 38    brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET
Rule 39    oper_add -> PLUS
Rule 40    oper_add -> MINUS
Rule 41    oper_mult -> MULT
Rule 42    oper_mult -> DIV
Rule 43    oper_mult -> MOD
Rule 44    oper_mult -> AND
Rule 45    oper_mult -> OR
Rule 46    oper_mult -> XOR
Rule 47    oper_mult -> LESSER
Rule 48    oper_mult -> GREATER
Rule 49    oper_mult -> EQUAL
Rule 50    oper_mult -> LESSER_EQ
Rule 51    oper_mult -> GREATER_EQ
Rule 52    factor -> ID
Rule 53    factor -> NUMBER
Rule 54    factor -> brac_expr
Rule 55    factor_n -> NOT factor
Rule 56    factor_n -> factor
Rule 57    comp -> comp oper_mult factor_n
Rule 58    comp -> factor_n

Terminals, with rules where they appear

AND                  : 44
ASSIGN               : 18 19
BEGIN                : 2 14
CLOSE_BRACKET        : 13 14 28 32 38
CLOSE_CURL_BRACKET   : 
CLOSE_SQ_BRACKET     : 
COMMENT              : 
DIV                  : 42
ELSE                 : 35
END                  : 2 33 35
ENDLINE              : 9
EQUAL                : 49
FUNCTION             : 14
GREATER              : 48
GREATER_EQ           : 51
ID                   : 14 15 18 19 28 29 52
IF                   : 32
INT                  : 26
ITERABLE_LOOP        : 
LESSER               : 47
LESSER_EQ            : 50
LIST                 : 
LOOP                 : 13
MINUS                : 40
MOD                  : 43
MULT                 : 41
NOT                  : 55
NULL                 : 
NUMBER               : 20 53
N_EQUAL              : 
OPEN_BRACKET         : 13 14 28 32 38
OPEN_CURL_BRACKET    : 
OPEN_SQ_BRACKET      : 
OR                   : 45
PLUS                 : 39
PRINT                : 
PROGRAM              : 1
RETURN               : 14
STRING               : 27
STRING_EXPR          : 21
THEN                 : 32 35
XOR                  : 46
error                : 

Nonterminals, with rules where they appear

arg                  : 30 31
args                 : 14 30
block                : 1 13
block_body           : 2 14 32 35
brac_expr            : 54
comp                 : 36 37 57
else_stat            : 34
end_if               : 32
expr                 : 13 16 23 32 36 38
factor               : 55 56
factor_n             : 57 58
func_call            : 11 17 22
func_decl            : 6
if_stat              : 5
line                 : 7 8
line_body            : 9
lines                : 3 7
loop                 : 4
oper_add             : 36
oper_mult            : 57
program_decl         : 0
return_val           : 14
type                 : 18 29
value                : 18 19 24 25
values               : 24 28
var_assign           : 12
var_decl             : 10

Parsing method: LALR

state 0

    (0) S' -> . program_decl
    (1) program_decl -> . PROGRAM block

    PROGRAM         shift and go to state 2

    program_decl                   shift and go to state 1

state 1

    (0) S' -> program_decl .



state 2

    (1) program_decl -> PROGRAM . block
    (2) block -> . BEGIN block_body END

    BEGIN           shift and go to state 4

    block                          shift and go to state 3

state 3

    (1) program_decl -> PROGRAM block .

    $end            reduce using rule 1 (program_decl -> PROGRAM block .)


state 4

    (2) block -> BEGIN . block_body END
    (3) block_body -> . lines
    (4) block_body -> . loop
    (5) block_body -> . if_stat
    (6) block_body -> . func_decl
    (7) lines -> . lines line
    (8) lines -> . line
    (13) loop -> . LOOP OPEN_BRACKET expr CLOSE_BRACKET block
    (32) if_stat -> . IF OPEN_BRACKET expr CLOSE_BRACKET THEN block_body end_if
    (14) func_decl -> . FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN block_body RETURN return_val
    (9) line -> . line_body ENDLINE
    (10) line_body -> . var_decl
    (11) line_body -> . func_call
    (12) line_body -> . var_assign
    (18) var_decl -> . type ID ASSIGN value
    (28) func_call -> . ID OPEN_BRACKET values CLOSE_BRACKET
    (19) var_assign -> . ID ASSIGN value
    (26) type -> . INT
    (27) type -> . STRING

    LOOP            shift and go to state 11
    IF              shift and go to state 12
    FUNCTION        shift and go to state 13
    ID              shift and go to state 14
    INT             shift and go to state 20
    STRING          shift and go to state 21

    block_body                     shift and go to state 5
    lines                          shift and go to state 6
    loop                           shift and go to state 7
    if_stat                        shift and go to state 8
    func_decl                      shift and go to state 9
    line                           shift and go to state 10
    line_body                      shift and go to state 15
    var_decl                       shift and go to state 16
    func_call                      shift and go to state 17
    var_assign                     shift and go to state 18
    type                           shift and go to state 19

state 5

    (2) block -> BEGIN block_body . END

    END             shift and go to state 22


state 6

    (3) block_body -> lines .
    (7) lines -> lines . line
    (9) line -> . line_body ENDLINE
    (10) line_body -> . var_decl
    (11) line_body -> . func_call
    (12) line_body -> . var_assign
    (18) var_decl -> . type ID ASSIGN value
    (28) func_call -> . ID OPEN_BRACKET values CLOSE_BRACKET
    (19) var_assign -> . ID ASSIGN value
    (26) type -> . INT
    (27) type -> . STRING

    END             reduce using rule 3 (block_body -> lines .)
    ELSE            reduce using rule 3 (block_body -> lines .)
    RETURN          reduce using rule 3 (block_body -> lines .)
    ID              shift and go to state 14
    INT             shift and go to state 20
    STRING          shift and go to state 21

    line                           shift and go to state 23
    line_body                      shift and go to state 15
    var_decl                       shift and go to state 16
    func_call                      shift and go to state 17
    var_assign                     shift and go to state 18
    type                           shift and go to state 19

state 7

    (4) block_body -> loop .

    END             reduce using rule 4 (block_body -> loop .)
    ELSE            reduce using rule 4 (block_body -> loop .)
    RETURN          reduce using rule 4 (block_body -> loop .)


state 8

    (5) block_body -> if_stat .

    END             reduce using rule 5 (block_body -> if_stat .)
    ELSE            reduce using rule 5 (block_body -> if_stat .)
    RETURN          reduce using rule 5 (block_body -> if_stat .)


state 9

    (6) block_body -> func_decl .

    END             reduce using rule 6 (block_body -> func_decl .)
    ELSE            reduce using rule 6 (block_body -> func_decl .)
    RETURN          reduce using rule 6 (block_body -> func_decl .)


state 10

    (8) lines -> line .

    ID              reduce using rule 8 (lines -> line .)
    INT             reduce using rule 8 (lines -> line .)
    STRING          reduce using rule 8 (lines -> line .)
    END             reduce using rule 8 (lines -> line .)
    ELSE            reduce using rule 8 (lines -> line .)
    RETURN          reduce using rule 8 (lines -> line .)


state 11

    (13) loop -> LOOP . OPEN_BRACKET expr CLOSE_BRACKET block

    OPEN_BRACKET    shift and go to state 24


state 12

    (32) if_stat -> IF . OPEN_BRACKET expr CLOSE_BRACKET THEN block_body end_if

    OPEN_BRACKET    shift and go to state 25


state 13

    (14) func_decl -> FUNCTION . ID OPEN_BRACKET args CLOSE_BRACKET BEGIN block_body RETURN return_val

    ID              shift and go to state 26


state 14

    (28) func_call -> ID . OPEN_BRACKET values CLOSE_BRACKET
    (19) var_assign -> ID . ASSIGN value

    OPEN_BRACKET    shift and go to state 27
    ASSIGN          shift and go to state 28


state 15

    (9) line -> line_body . ENDLINE

    ENDLINE         shift and go to state 29


state 16

    (10) line_body -> var_decl .

    ENDLINE         reduce using rule 10 (line_body -> var_decl .)


state 17

    (11) line_body -> func_call .

    ENDLINE         reduce using rule 11 (line_body -> func_call .)


state 18

    (12) line_body -> var_assign .

    ENDLINE         reduce using rule 12 (line_body -> var_assign .)


state 19

    (18) var_decl -> type . ID ASSIGN value

    ID              shift and go to state 30


state 20

    (26) type -> INT .

    ID              reduce using rule 26 (type -> INT .)


state 21

    (27) type -> STRING .

    ID              reduce using rule 27 (type -> STRING .)


state 22

    (2) block -> BEGIN block_body END .

    $end            reduce using rule 2 (block -> BEGIN block_body END .)
    END             reduce using rule 2 (block -> BEGIN block_body END .)
    ELSE            reduce using rule 2 (block -> BEGIN block_body END .)
    RETURN          reduce using rule 2 (block -> BEGIN block_body END .)


state 23

    (7) lines -> lines line .

    ID              reduce using rule 7 (lines -> lines line .)
    INT             reduce using rule 7 (lines -> lines line .)
    STRING          reduce using rule 7 (lines -> lines line .)
    END             reduce using rule 7 (lines -> lines line .)
    ELSE            reduce using rule 7 (lines -> lines line .)
    RETURN          reduce using rule 7 (lines -> lines line .)


state 24

    (13) loop -> LOOP OPEN_BRACKET . expr CLOSE_BRACKET block
    (36) expr -> . expr oper_add comp
    (37) expr -> . comp
    (57) comp -> . comp oper_mult factor_n
    (58) comp -> . factor_n
    (55) factor_n -> . NOT factor
    (56) factor_n -> . factor
    (52) factor -> . ID
    (53) factor -> . NUMBER
    (54) factor -> . brac_expr
    (38) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET

    NOT             shift and go to state 35
    ID              shift and go to state 37
    NUMBER          shift and go to state 38
    OPEN_BRACKET    shift and go to state 31

    expr                           shift and go to state 32
    comp                           shift and go to state 33
    factor_n                       shift and go to state 34
    factor                         shift and go to state 36
    brac_expr                      shift and go to state 39

state 25

    (32) if_stat -> IF OPEN_BRACKET . expr CLOSE_BRACKET THEN block_body end_if
    (36) expr -> . expr oper_add comp
    (37) expr -> . comp
    (57) comp -> . comp oper_mult factor_n
    (58) comp -> . factor_n
    (55) factor_n -> . NOT factor
    (56) factor_n -> . factor
    (52) factor -> . ID
    (53) factor -> . NUMBER
    (54) factor -> . brac_expr
    (38) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET

    NOT             shift and go to state 35
    ID              shift and go to state 37
    NUMBER          shift and go to state 38
    OPEN_BRACKET    shift and go to state 31

    expr                           shift and go to state 40
    comp                           shift and go to state 33
    factor_n                       shift and go to state 34
    factor                         shift and go to state 36
    brac_expr                      shift and go to state 39

state 26

    (14) func_decl -> FUNCTION ID . OPEN_BRACKET args CLOSE_BRACKET BEGIN block_body RETURN return_val

    OPEN_BRACKET    shift and go to state 41


state 27

    (28) func_call -> ID OPEN_BRACKET . values CLOSE_BRACKET
    (24) values -> . values value
    (25) values -> . value
    (20) value -> . NUMBER
    (21) value -> . STRING_EXPR
    (22) value -> . func_call
    (23) value -> . expr
    (28) func_call -> . ID OPEN_BRACKET values CLOSE_BRACKET
    (36) expr -> . expr oper_add comp
    (37) expr -> . comp
    (57) comp -> . comp oper_mult factor_n
    (58) comp -> . factor_n
    (55) factor_n -> . NOT factor
    (56) factor_n -> . factor
    (52) factor -> . ID
    (53) factor -> . NUMBER
    (54) factor -> . brac_expr
    (38) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET

    NUMBER          shift and go to state 45
    STRING_EXPR     shift and go to state 46
    ID              shift and go to state 42
    NOT             shift and go to state 35
    OPEN_BRACKET    shift and go to state 31

    values                         shift and go to state 43
    value                          shift and go to state 44
    func_call                      shift and go to state 47
    expr                           shift and go to state 48
    comp                           shift and go to state 33
    factor_n                       shift and go to state 34
    factor                         shift and go to state 36
    brac_expr                      shift and go to state 39

state 28

    (19) var_assign -> ID ASSIGN . value
    (20) value -> . NUMBER
    (21) value -> . STRING_EXPR
    (22) value -> . func_call
    (23) value -> . expr
    (28) func_call -> . ID OPEN_BRACKET values CLOSE_BRACKET
    (36) expr -> . expr oper_add comp
    (37) expr -> . comp
    (57) comp -> . comp oper_mult factor_n
    (58) comp -> . factor_n
    (55) factor_n -> . NOT factor
    (56) factor_n -> . factor
    (52) factor -> . ID
    (53) factor -> . NUMBER
    (54) factor -> . brac_expr
    (38) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET

    NUMBER          shift and go to state 45
    STRING_EXPR     shift and go to state 46
    ID              shift and go to state 42
    NOT             shift and go to state 35
    OPEN_BRACKET    shift and go to state 31

    value                          shift and go to state 49
    func_call                      shift and go to state 47
    expr                           shift and go to state 48
    comp                           shift and go to state 33
    factor_n                       shift and go to state 34
    factor                         shift and go to state 36
    brac_expr                      shift and go to state 39

state 29

    (9) line -> line_body ENDLINE .

    ID              reduce using rule 9 (line -> line_body ENDLINE .)
    INT             reduce using rule 9 (line -> line_body ENDLINE .)
    STRING          reduce using rule 9 (line -> line_body ENDLINE .)
    END             reduce using rule 9 (line -> line_body ENDLINE .)
    ELSE            reduce using rule 9 (line -> line_body ENDLINE .)
    RETURN          reduce using rule 9 (line -> line_body ENDLINE .)


state 30

    (18) var_decl -> type ID . ASSIGN value

    ASSIGN          shift and go to state 50


state 31

    (38) brac_expr -> OPEN_BRACKET . expr CLOSE_BRACKET
    (36) expr -> . expr oper_add comp
    (37) expr -> . comp
    (57) comp -> . comp oper_mult factor_n
    (58) comp -> . factor_n
    (55) factor_n -> . NOT factor
    (56) factor_n -> . factor
    (52) factor -> . ID
    (53) factor -> . NUMBER
    (54) factor -> . brac_expr
    (38) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET

    NOT             shift and go to state 35
    ID              shift and go to state 37
    NUMBER          shift and go to state 38
    OPEN_BRACKET    shift and go to state 31

    expr                           shift and go to state 51
    comp                           shift and go to state 33
    factor_n                       shift and go to state 34
    factor                         shift and go to state 36
    brac_expr                      shift and go to state 39

state 32

    (13) loop -> LOOP OPEN_BRACKET expr . CLOSE_BRACKET block
    (36) expr -> expr . oper_add comp
    (39) oper_add -> . PLUS
    (40) oper_add -> . MINUS

    CLOSE_BRACKET   shift and go to state 52
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55

    oper_add                       shift and go to state 53

state 33

    (37) expr -> comp .
    (57) comp -> comp . oper_mult factor_n
    (41) oper_mult -> . MULT
    (42) oper_mult -> . DIV
    (43) oper_mult -> . MOD
    (44) oper_mult -> . AND
    (45) oper_mult -> . OR
    (46) oper_mult -> . XOR
    (47) oper_mult -> . LESSER
    (48) oper_mult -> . GREATER
    (49) oper_mult -> . EQUAL
    (50) oper_mult -> . LESSER_EQ
    (51) oper_mult -> . GREATER_EQ

    CLOSE_BRACKET   reduce using rule 37 (expr -> comp .)
    PLUS            reduce using rule 37 (expr -> comp .)
    MINUS           reduce using rule 37 (expr -> comp .)
    NUMBER          reduce using rule 37 (expr -> comp .)
    STRING_EXPR     reduce using rule 37 (expr -> comp .)
    ID              reduce using rule 37 (expr -> comp .)
    NOT             reduce using rule 37 (expr -> comp .)
    OPEN_BRACKET    reduce using rule 37 (expr -> comp .)
    ENDLINE         reduce using rule 37 (expr -> comp .)
    END             reduce using rule 37 (expr -> comp .)
    ELSE            reduce using rule 37 (expr -> comp .)
    RETURN          reduce using rule 37 (expr -> comp .)
    MULT            shift and go to state 57
    DIV             shift and go to state 58
    MOD             shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    XOR             shift and go to state 62
    LESSER          shift and go to state 63
    GREATER         shift and go to state 64
    EQUAL           shift and go to state 65
    LESSER_EQ       shift and go to state 66
    GREATER_EQ      shift and go to state 67

    oper_mult                      shift and go to state 56

state 34

    (58) comp -> factor_n .

    MULT            reduce using rule 58 (comp -> factor_n .)
    DIV             reduce using rule 58 (comp -> factor_n .)
    MOD             reduce using rule 58 (comp -> factor_n .)
    AND             reduce using rule 58 (comp -> factor_n .)
    OR              reduce using rule 58 (comp -> factor_n .)
    XOR             reduce using rule 58 (comp -> factor_n .)
    LESSER          reduce using rule 58 (comp -> factor_n .)
    GREATER         reduce using rule 58 (comp -> factor_n .)
    EQUAL           reduce using rule 58 (comp -> factor_n .)
    LESSER_EQ       reduce using rule 58 (comp -> factor_n .)
    GREATER_EQ      reduce using rule 58 (comp -> factor_n .)
    CLOSE_BRACKET   reduce using rule 58 (comp -> factor_n .)
    PLUS            reduce using rule 58 (comp -> factor_n .)
    MINUS           reduce using rule 58 (comp -> factor_n .)
    NUMBER          reduce using rule 58 (comp -> factor_n .)
    STRING_EXPR     reduce using rule 58 (comp -> factor_n .)
    ID              reduce using rule 58 (comp -> factor_n .)
    NOT             reduce using rule 58 (comp -> factor_n .)
    OPEN_BRACKET    reduce using rule 58 (comp -> factor_n .)
    ENDLINE         reduce using rule 58 (comp -> factor_n .)
    END             reduce using rule 58 (comp -> factor_n .)
    ELSE            reduce using rule 58 (comp -> factor_n .)
    RETURN          reduce using rule 58 (comp -> factor_n .)


state 35

    (55) factor_n -> NOT . factor
    (52) factor -> . ID
    (53) factor -> . NUMBER
    (54) factor -> . brac_expr
    (38) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET

    ID              shift and go to state 37
    NUMBER          shift and go to state 38
    OPEN_BRACKET    shift and go to state 31

    factor                         shift and go to state 68
    brac_expr                      shift and go to state 39

state 36

    (56) factor_n -> factor .

    MULT            reduce using rule 56 (factor_n -> factor .)
    DIV             reduce using rule 56 (factor_n -> factor .)
    MOD             reduce using rule 56 (factor_n -> factor .)
    AND             reduce using rule 56 (factor_n -> factor .)
    OR              reduce using rule 56 (factor_n -> factor .)
    XOR             reduce using rule 56 (factor_n -> factor .)
    LESSER          reduce using rule 56 (factor_n -> factor .)
    GREATER         reduce using rule 56 (factor_n -> factor .)
    EQUAL           reduce using rule 56 (factor_n -> factor .)
    LESSER_EQ       reduce using rule 56 (factor_n -> factor .)
    GREATER_EQ      reduce using rule 56 (factor_n -> factor .)
    CLOSE_BRACKET   reduce using rule 56 (factor_n -> factor .)
    PLUS            reduce using rule 56 (factor_n -> factor .)
    MINUS           reduce using rule 56 (factor_n -> factor .)
    NUMBER          reduce using rule 56 (factor_n -> factor .)
    STRING_EXPR     reduce using rule 56 (factor_n -> factor .)
    ID              reduce using rule 56 (factor_n -> factor .)
    NOT             reduce using rule 56 (factor_n -> factor .)
    OPEN_BRACKET    reduce using rule 56 (factor_n -> factor .)
    ENDLINE         reduce using rule 56 (factor_n -> factor .)
    END             reduce using rule 56 (factor_n -> factor .)
    ELSE            reduce using rule 56 (factor_n -> factor .)
    RETURN          reduce using rule 56 (factor_n -> factor .)


state 37

    (52) factor -> ID .

    MULT            reduce using rule 52 (factor -> ID .)
    DIV             reduce using rule 52 (factor -> ID .)
    MOD             reduce using rule 52 (factor -> ID .)
    AND             reduce using rule 52 (factor -> ID .)
    OR              reduce using rule 52 (factor -> ID .)
    XOR             reduce using rule 52 (factor -> ID .)
    LESSER          reduce using rule 52 (factor -> ID .)
    GREATER         reduce using rule 52 (factor -> ID .)
    EQUAL           reduce using rule 52 (factor -> ID .)
    LESSER_EQ       reduce using rule 52 (factor -> ID .)
    GREATER_EQ      reduce using rule 52 (factor -> ID .)
    CLOSE_BRACKET   reduce using rule 52 (factor -> ID .)
    PLUS            reduce using rule 52 (factor -> ID .)
    MINUS           reduce using rule 52 (factor -> ID .)
    NUMBER          reduce using rule 52 (factor -> ID .)
    STRING_EXPR     reduce using rule 52 (factor -> ID .)
    ID              reduce using rule 52 (factor -> ID .)
    NOT             reduce using rule 52 (factor -> ID .)
    OPEN_BRACKET    reduce using rule 52 (factor -> ID .)
    ENDLINE         reduce using rule 52 (factor -> ID .)
    END             reduce using rule 52 (factor -> ID .)
    ELSE            reduce using rule 52 (factor -> ID .)
    RETURN          reduce using rule 52 (factor -> ID .)


state 38

    (53) factor -> NUMBER .

    MULT            reduce using rule 53 (factor -> NUMBER .)
    DIV             reduce using rule 53 (factor -> NUMBER .)
    MOD             reduce using rule 53 (factor -> NUMBER .)
    AND             reduce using rule 53 (factor -> NUMBER .)
    OR              reduce using rule 53 (factor -> NUMBER .)
    XOR             reduce using rule 53 (factor -> NUMBER .)
    LESSER          reduce using rule 53 (factor -> NUMBER .)
    GREATER         reduce using rule 53 (factor -> NUMBER .)
    EQUAL           reduce using rule 53 (factor -> NUMBER .)
    LESSER_EQ       reduce using rule 53 (factor -> NUMBER .)
    GREATER_EQ      reduce using rule 53 (factor -> NUMBER .)
    CLOSE_BRACKET   reduce using rule 53 (factor -> NUMBER .)
    PLUS            reduce using rule 53 (factor -> NUMBER .)
    MINUS           reduce using rule 53 (factor -> NUMBER .)
    NUMBER          reduce using rule 53 (factor -> NUMBER .)
    STRING_EXPR     reduce using rule 53 (factor -> NUMBER .)
    ID              reduce using rule 53 (factor -> NUMBER .)
    NOT             reduce using rule 53 (factor -> NUMBER .)
    OPEN_BRACKET    reduce using rule 53 (factor -> NUMBER .)
    ENDLINE         reduce using rule 53 (factor -> NUMBER .)
    END             reduce using rule 53 (factor -> NUMBER .)
    ELSE            reduce using rule 53 (factor -> NUMBER .)
    RETURN          reduce using rule 53 (factor -> NUMBER .)


state 39

    (54) factor -> brac_expr .

    MULT            reduce using rule 54 (factor -> brac_expr .)
    DIV             reduce using rule 54 (factor -> brac_expr .)
    MOD             reduce using rule 54 (factor -> brac_expr .)
    AND             reduce using rule 54 (factor -> brac_expr .)
    OR              reduce using rule 54 (factor -> brac_expr .)
    XOR             reduce using rule 54 (factor -> brac_expr .)
    LESSER          reduce using rule 54 (factor -> brac_expr .)
    GREATER         reduce using rule 54 (factor -> brac_expr .)
    EQUAL           reduce using rule 54 (factor -> brac_expr .)
    LESSER_EQ       reduce using rule 54 (factor -> brac_expr .)
    GREATER_EQ      reduce using rule 54 (factor -> brac_expr .)
    CLOSE_BRACKET   reduce using rule 54 (factor -> brac_expr .)
    PLUS            reduce using rule 54 (factor -> brac_expr .)
    MINUS           reduce using rule 54 (factor -> brac_expr .)
    NUMBER          reduce using rule 54 (factor -> brac_expr .)
    STRING_EXPR     reduce using rule 54 (factor -> brac_expr .)
    ID              reduce using rule 54 (factor -> brac_expr .)
    NOT             reduce using rule 54 (factor -> brac_expr .)
    OPEN_BRACKET    reduce using rule 54 (factor -> brac_expr .)
    ENDLINE         reduce using rule 54 (factor -> brac_expr .)
    END             reduce using rule 54 (factor -> brac_expr .)
    ELSE            reduce using rule 54 (factor -> brac_expr .)
    RETURN          reduce using rule 54 (factor -> brac_expr .)


state 40

    (32) if_stat -> IF OPEN_BRACKET expr . CLOSE_BRACKET THEN block_body end_if
    (36) expr -> expr . oper_add comp
    (39) oper_add -> . PLUS
    (40) oper_add -> . MINUS

    CLOSE_BRACKET   shift and go to state 69
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55

    oper_add                       shift and go to state 53

state 41

    (14) func_decl -> FUNCTION ID OPEN_BRACKET . args CLOSE_BRACKET BEGIN block_body RETURN return_val
    (30) args -> . args arg
    (31) args -> . arg
    (29) arg -> . type ID
    (26) type -> . INT
    (27) type -> . STRING

    INT             shift and go to state 20
    STRING          shift and go to state 21

    args                           shift and go to state 70
    arg                            shift and go to state 71
    type                           shift and go to state 72

state 42

    (28) func_call -> ID . OPEN_BRACKET values CLOSE_BRACKET
    (52) factor -> ID .

  ! shift/reduce conflict for OPEN_BRACKET resolved as shift
    OPEN_BRACKET    shift and go to state 27
    MULT            reduce using rule 52 (factor -> ID .)
    DIV             reduce using rule 52 (factor -> ID .)
    MOD             reduce using rule 52 (factor -> ID .)
    AND             reduce using rule 52 (factor -> ID .)
    OR              reduce using rule 52 (factor -> ID .)
    XOR             reduce using rule 52 (factor -> ID .)
    LESSER          reduce using rule 52 (factor -> ID .)
    GREATER         reduce using rule 52 (factor -> ID .)
    EQUAL           reduce using rule 52 (factor -> ID .)
    LESSER_EQ       reduce using rule 52 (factor -> ID .)
    GREATER_EQ      reduce using rule 52 (factor -> ID .)
    PLUS            reduce using rule 52 (factor -> ID .)
    MINUS           reduce using rule 52 (factor -> ID .)
    CLOSE_BRACKET   reduce using rule 52 (factor -> ID .)
    NUMBER          reduce using rule 52 (factor -> ID .)
    STRING_EXPR     reduce using rule 52 (factor -> ID .)
    ID              reduce using rule 52 (factor -> ID .)
    NOT             reduce using rule 52 (factor -> ID .)
    ENDLINE         reduce using rule 52 (factor -> ID .)

  ! OPEN_BRACKET    [ reduce using rule 52 (factor -> ID .) ]


state 43

    (28) func_call -> ID OPEN_BRACKET values . CLOSE_BRACKET
    (24) values -> values . value
    (20) value -> . NUMBER
    (21) value -> . STRING_EXPR
    (22) value -> . func_call
    (23) value -> . expr
    (28) func_call -> . ID OPEN_BRACKET values CLOSE_BRACKET
    (36) expr -> . expr oper_add comp
    (37) expr -> . comp
    (57) comp -> . comp oper_mult factor_n
    (58) comp -> . factor_n
    (55) factor_n -> . NOT factor
    (56) factor_n -> . factor
    (52) factor -> . ID
    (53) factor -> . NUMBER
    (54) factor -> . brac_expr
    (38) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 73
    NUMBER          shift and go to state 45
    STRING_EXPR     shift and go to state 46
    ID              shift and go to state 42
    NOT             shift and go to state 35
    OPEN_BRACKET    shift and go to state 31

    value                          shift and go to state 74
    func_call                      shift and go to state 47
    expr                           shift and go to state 48
    comp                           shift and go to state 33
    factor_n                       shift and go to state 34
    factor                         shift and go to state 36
    brac_expr                      shift and go to state 39

state 44

    (25) values -> value .

    CLOSE_BRACKET   reduce using rule 25 (values -> value .)
    NUMBER          reduce using rule 25 (values -> value .)
    STRING_EXPR     reduce using rule 25 (values -> value .)
    ID              reduce using rule 25 (values -> value .)
    NOT             reduce using rule 25 (values -> value .)
    OPEN_BRACKET    reduce using rule 25 (values -> value .)


state 45

    (20) value -> NUMBER .
    (53) factor -> NUMBER .

  ! reduce/reduce conflict for CLOSE_BRACKET resolved using rule 20 (value -> NUMBER .)
  ! reduce/reduce conflict for NUMBER resolved using rule 20 (value -> NUMBER .)
  ! reduce/reduce conflict for STRING_EXPR resolved using rule 20 (value -> NUMBER .)
  ! reduce/reduce conflict for ID resolved using rule 20 (value -> NUMBER .)
  ! reduce/reduce conflict for NOT resolved using rule 20 (value -> NUMBER .)
  ! reduce/reduce conflict for OPEN_BRACKET resolved using rule 20 (value -> NUMBER .)
  ! reduce/reduce conflict for ENDLINE resolved using rule 20 (value -> NUMBER .)
    CLOSE_BRACKET   reduce using rule 20 (value -> NUMBER .)
    NUMBER          reduce using rule 20 (value -> NUMBER .)
    STRING_EXPR     reduce using rule 20 (value -> NUMBER .)
    ID              reduce using rule 20 (value -> NUMBER .)
    NOT             reduce using rule 20 (value -> NUMBER .)
    OPEN_BRACKET    reduce using rule 20 (value -> NUMBER .)
    ENDLINE         reduce using rule 20 (value -> NUMBER .)
    MULT            reduce using rule 53 (factor -> NUMBER .)
    DIV             reduce using rule 53 (factor -> NUMBER .)
    MOD             reduce using rule 53 (factor -> NUMBER .)
    AND             reduce using rule 53 (factor -> NUMBER .)
    OR              reduce using rule 53 (factor -> NUMBER .)
    XOR             reduce using rule 53 (factor -> NUMBER .)
    LESSER          reduce using rule 53 (factor -> NUMBER .)
    GREATER         reduce using rule 53 (factor -> NUMBER .)
    EQUAL           reduce using rule 53 (factor -> NUMBER .)
    LESSER_EQ       reduce using rule 53 (factor -> NUMBER .)
    GREATER_EQ      reduce using rule 53 (factor -> NUMBER .)
    PLUS            reduce using rule 53 (factor -> NUMBER .)
    MINUS           reduce using rule 53 (factor -> NUMBER .)

  ! CLOSE_BRACKET   [ reduce using rule 53 (factor -> NUMBER .) ]
  ! NUMBER          [ reduce using rule 53 (factor -> NUMBER .) ]
  ! STRING_EXPR     [ reduce using rule 53 (factor -> NUMBER .) ]
  ! ID              [ reduce using rule 53 (factor -> NUMBER .) ]
  ! NOT             [ reduce using rule 53 (factor -> NUMBER .) ]
  ! OPEN_BRACKET    [ reduce using rule 53 (factor -> NUMBER .) ]
  ! ENDLINE         [ reduce using rule 53 (factor -> NUMBER .) ]


state 46

    (21) value -> STRING_EXPR .

    CLOSE_BRACKET   reduce using rule 21 (value -> STRING_EXPR .)
    NUMBER          reduce using rule 21 (value -> STRING_EXPR .)
    STRING_EXPR     reduce using rule 21 (value -> STRING_EXPR .)
    ID              reduce using rule 21 (value -> STRING_EXPR .)
    NOT             reduce using rule 21 (value -> STRING_EXPR .)
    OPEN_BRACKET    reduce using rule 21 (value -> STRING_EXPR .)
    ENDLINE         reduce using rule 21 (value -> STRING_EXPR .)


state 47

    (22) value -> func_call .

    CLOSE_BRACKET   reduce using rule 22 (value -> func_call .)
    NUMBER          reduce using rule 22 (value -> func_call .)
    STRING_EXPR     reduce using rule 22 (value -> func_call .)
    ID              reduce using rule 22 (value -> func_call .)
    NOT             reduce using rule 22 (value -> func_call .)
    OPEN_BRACKET    reduce using rule 22 (value -> func_call .)
    ENDLINE         reduce using rule 22 (value -> func_call .)


state 48

    (23) value -> expr .
    (36) expr -> expr . oper_add comp
    (39) oper_add -> . PLUS
    (40) oper_add -> . MINUS

    CLOSE_BRACKET   reduce using rule 23 (value -> expr .)
    NUMBER          reduce using rule 23 (value -> expr .)
    STRING_EXPR     reduce using rule 23 (value -> expr .)
    ID              reduce using rule 23 (value -> expr .)
    NOT             reduce using rule 23 (value -> expr .)
    OPEN_BRACKET    reduce using rule 23 (value -> expr .)
    ENDLINE         reduce using rule 23 (value -> expr .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55

    oper_add                       shift and go to state 53

state 49

    (19) var_assign -> ID ASSIGN value .

    ENDLINE         reduce using rule 19 (var_assign -> ID ASSIGN value .)


state 50

    (18) var_decl -> type ID ASSIGN . value
    (20) value -> . NUMBER
    (21) value -> . STRING_EXPR
    (22) value -> . func_call
    (23) value -> . expr
    (28) func_call -> . ID OPEN_BRACKET values CLOSE_BRACKET
    (36) expr -> . expr oper_add comp
    (37) expr -> . comp
    (57) comp -> . comp oper_mult factor_n
    (58) comp -> . factor_n
    (55) factor_n -> . NOT factor
    (56) factor_n -> . factor
    (52) factor -> . ID
    (53) factor -> . NUMBER
    (54) factor -> . brac_expr
    (38) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET

    NUMBER          shift and go to state 45
    STRING_EXPR     shift and go to state 46
    ID              shift and go to state 42
    NOT             shift and go to state 35
    OPEN_BRACKET    shift and go to state 31

    value                          shift and go to state 75
    func_call                      shift and go to state 47
    expr                           shift and go to state 48
    comp                           shift and go to state 33
    factor_n                       shift and go to state 34
    factor                         shift and go to state 36
    brac_expr                      shift and go to state 39

state 51

    (38) brac_expr -> OPEN_BRACKET expr . CLOSE_BRACKET
    (36) expr -> expr . oper_add comp
    (39) oper_add -> . PLUS
    (40) oper_add -> . MINUS

    CLOSE_BRACKET   shift and go to state 76
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55

    oper_add                       shift and go to state 53

state 52

    (13) loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET . block
    (2) block -> . BEGIN block_body END

    BEGIN           shift and go to state 4

    block                          shift and go to state 77

state 53

    (36) expr -> expr oper_add . comp
    (57) comp -> . comp oper_mult factor_n
    (58) comp -> . factor_n
    (55) factor_n -> . NOT factor
    (56) factor_n -> . factor
    (52) factor -> . ID
    (53) factor -> . NUMBER
    (54) factor -> . brac_expr
    (38) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET

    NOT             shift and go to state 35
    ID              shift and go to state 37
    NUMBER          shift and go to state 38
    OPEN_BRACKET    shift and go to state 31

    comp                           shift and go to state 78
    factor_n                       shift and go to state 34
    factor                         shift and go to state 36
    brac_expr                      shift and go to state 39

state 54

    (39) oper_add -> PLUS .

    NOT             reduce using rule 39 (oper_add -> PLUS .)
    ID              reduce using rule 39 (oper_add -> PLUS .)
    NUMBER          reduce using rule 39 (oper_add -> PLUS .)
    OPEN_BRACKET    reduce using rule 39 (oper_add -> PLUS .)


state 55

    (40) oper_add -> MINUS .

    NOT             reduce using rule 40 (oper_add -> MINUS .)
    ID              reduce using rule 40 (oper_add -> MINUS .)
    NUMBER          reduce using rule 40 (oper_add -> MINUS .)
    OPEN_BRACKET    reduce using rule 40 (oper_add -> MINUS .)


state 56

    (57) comp -> comp oper_mult . factor_n
    (55) factor_n -> . NOT factor
    (56) factor_n -> . factor
    (52) factor -> . ID
    (53) factor -> . NUMBER
    (54) factor -> . brac_expr
    (38) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET

    NOT             shift and go to state 35
    ID              shift and go to state 37
    NUMBER          shift and go to state 38
    OPEN_BRACKET    shift and go to state 31

    factor_n                       shift and go to state 79
    factor                         shift and go to state 36
    brac_expr                      shift and go to state 39

state 57

    (41) oper_mult -> MULT .

    NOT             reduce using rule 41 (oper_mult -> MULT .)
    ID              reduce using rule 41 (oper_mult -> MULT .)
    NUMBER          reduce using rule 41 (oper_mult -> MULT .)
    OPEN_BRACKET    reduce using rule 41 (oper_mult -> MULT .)


state 58

    (42) oper_mult -> DIV .

    NOT             reduce using rule 42 (oper_mult -> DIV .)
    ID              reduce using rule 42 (oper_mult -> DIV .)
    NUMBER          reduce using rule 42 (oper_mult -> DIV .)
    OPEN_BRACKET    reduce using rule 42 (oper_mult -> DIV .)


state 59

    (43) oper_mult -> MOD .

    NOT             reduce using rule 43 (oper_mult -> MOD .)
    ID              reduce using rule 43 (oper_mult -> MOD .)
    NUMBER          reduce using rule 43 (oper_mult -> MOD .)
    OPEN_BRACKET    reduce using rule 43 (oper_mult -> MOD .)


state 60

    (44) oper_mult -> AND .

    NOT             reduce using rule 44 (oper_mult -> AND .)
    ID              reduce using rule 44 (oper_mult -> AND .)
    NUMBER          reduce using rule 44 (oper_mult -> AND .)
    OPEN_BRACKET    reduce using rule 44 (oper_mult -> AND .)


state 61

    (45) oper_mult -> OR .

    NOT             reduce using rule 45 (oper_mult -> OR .)
    ID              reduce using rule 45 (oper_mult -> OR .)
    NUMBER          reduce using rule 45 (oper_mult -> OR .)
    OPEN_BRACKET    reduce using rule 45 (oper_mult -> OR .)


state 62

    (46) oper_mult -> XOR .

    NOT             reduce using rule 46 (oper_mult -> XOR .)
    ID              reduce using rule 46 (oper_mult -> XOR .)
    NUMBER          reduce using rule 46 (oper_mult -> XOR .)
    OPEN_BRACKET    reduce using rule 46 (oper_mult -> XOR .)


state 63

    (47) oper_mult -> LESSER .

    NOT             reduce using rule 47 (oper_mult -> LESSER .)
    ID              reduce using rule 47 (oper_mult -> LESSER .)
    NUMBER          reduce using rule 47 (oper_mult -> LESSER .)
    OPEN_BRACKET    reduce using rule 47 (oper_mult -> LESSER .)


state 64

    (48) oper_mult -> GREATER .

    NOT             reduce using rule 48 (oper_mult -> GREATER .)
    ID              reduce using rule 48 (oper_mult -> GREATER .)
    NUMBER          reduce using rule 48 (oper_mult -> GREATER .)
    OPEN_BRACKET    reduce using rule 48 (oper_mult -> GREATER .)


state 65

    (49) oper_mult -> EQUAL .

    NOT             reduce using rule 49 (oper_mult -> EQUAL .)
    ID              reduce using rule 49 (oper_mult -> EQUAL .)
    NUMBER          reduce using rule 49 (oper_mult -> EQUAL .)
    OPEN_BRACKET    reduce using rule 49 (oper_mult -> EQUAL .)


state 66

    (50) oper_mult -> LESSER_EQ .

    NOT             reduce using rule 50 (oper_mult -> LESSER_EQ .)
    ID              reduce using rule 50 (oper_mult -> LESSER_EQ .)
    NUMBER          reduce using rule 50 (oper_mult -> LESSER_EQ .)
    OPEN_BRACKET    reduce using rule 50 (oper_mult -> LESSER_EQ .)


state 67

    (51) oper_mult -> GREATER_EQ .

    NOT             reduce using rule 51 (oper_mult -> GREATER_EQ .)
    ID              reduce using rule 51 (oper_mult -> GREATER_EQ .)
    NUMBER          reduce using rule 51 (oper_mult -> GREATER_EQ .)
    OPEN_BRACKET    reduce using rule 51 (oper_mult -> GREATER_EQ .)


state 68

    (55) factor_n -> NOT factor .

    MULT            reduce using rule 55 (factor_n -> NOT factor .)
    DIV             reduce using rule 55 (factor_n -> NOT factor .)
    MOD             reduce using rule 55 (factor_n -> NOT factor .)
    AND             reduce using rule 55 (factor_n -> NOT factor .)
    OR              reduce using rule 55 (factor_n -> NOT factor .)
    XOR             reduce using rule 55 (factor_n -> NOT factor .)
    LESSER          reduce using rule 55 (factor_n -> NOT factor .)
    GREATER         reduce using rule 55 (factor_n -> NOT factor .)
    EQUAL           reduce using rule 55 (factor_n -> NOT factor .)
    LESSER_EQ       reduce using rule 55 (factor_n -> NOT factor .)
    GREATER_EQ      reduce using rule 55 (factor_n -> NOT factor .)
    CLOSE_BRACKET   reduce using rule 55 (factor_n -> NOT factor .)
    PLUS            reduce using rule 55 (factor_n -> NOT factor .)
    MINUS           reduce using rule 55 (factor_n -> NOT factor .)
    NUMBER          reduce using rule 55 (factor_n -> NOT factor .)
    STRING_EXPR     reduce using rule 55 (factor_n -> NOT factor .)
    ID              reduce using rule 55 (factor_n -> NOT factor .)
    NOT             reduce using rule 55 (factor_n -> NOT factor .)
    OPEN_BRACKET    reduce using rule 55 (factor_n -> NOT factor .)
    ENDLINE         reduce using rule 55 (factor_n -> NOT factor .)
    END             reduce using rule 55 (factor_n -> NOT factor .)
    ELSE            reduce using rule 55 (factor_n -> NOT factor .)
    RETURN          reduce using rule 55 (factor_n -> NOT factor .)


state 69

    (32) if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET . THEN block_body end_if

    THEN            shift and go to state 80


state 70

    (14) func_decl -> FUNCTION ID OPEN_BRACKET args . CLOSE_BRACKET BEGIN block_body RETURN return_val
    (30) args -> args . arg
    (29) arg -> . type ID
    (26) type -> . INT
    (27) type -> . STRING

    CLOSE_BRACKET   shift and go to state 81
    INT             shift and go to state 20
    STRING          shift and go to state 21

    arg                            shift and go to state 82
    type                           shift and go to state 72

state 71

    (31) args -> arg .

    CLOSE_BRACKET   reduce using rule 31 (args -> arg .)
    INT             reduce using rule 31 (args -> arg .)
    STRING          reduce using rule 31 (args -> arg .)


state 72

    (29) arg -> type . ID

    ID              shift and go to state 83


state 73

    (28) func_call -> ID OPEN_BRACKET values CLOSE_BRACKET .

    ENDLINE         reduce using rule 28 (func_call -> ID OPEN_BRACKET values CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 28 (func_call -> ID OPEN_BRACKET values CLOSE_BRACKET .)
    NUMBER          reduce using rule 28 (func_call -> ID OPEN_BRACKET values CLOSE_BRACKET .)
    STRING_EXPR     reduce using rule 28 (func_call -> ID OPEN_BRACKET values CLOSE_BRACKET .)
    ID              reduce using rule 28 (func_call -> ID OPEN_BRACKET values CLOSE_BRACKET .)
    NOT             reduce using rule 28 (func_call -> ID OPEN_BRACKET values CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 28 (func_call -> ID OPEN_BRACKET values CLOSE_BRACKET .)
    END             reduce using rule 28 (func_call -> ID OPEN_BRACKET values CLOSE_BRACKET .)
    ELSE            reduce using rule 28 (func_call -> ID OPEN_BRACKET values CLOSE_BRACKET .)
    RETURN          reduce using rule 28 (func_call -> ID OPEN_BRACKET values CLOSE_BRACKET .)


state 74

    (24) values -> values value .

    CLOSE_BRACKET   reduce using rule 24 (values -> values value .)
    NUMBER          reduce using rule 24 (values -> values value .)
    STRING_EXPR     reduce using rule 24 (values -> values value .)
    ID              reduce using rule 24 (values -> values value .)
    NOT             reduce using rule 24 (values -> values value .)
    OPEN_BRACKET    reduce using rule 24 (values -> values value .)


state 75

    (18) var_decl -> type ID ASSIGN value .

    ENDLINE         reduce using rule 18 (var_decl -> type ID ASSIGN value .)


state 76

    (38) brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .

    MULT            reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    DIV             reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    MOD             reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    AND             reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    OR              reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    XOR             reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    LESSER          reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    GREATER         reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    EQUAL           reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    LESSER_EQ       reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    GREATER_EQ      reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    PLUS            reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    MINUS           reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    NUMBER          reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    STRING_EXPR     reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    ID              reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    NOT             reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    ENDLINE         reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    END             reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    ELSE            reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    RETURN          reduce using rule 38 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)


state 77

    (13) loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET block .

    END             reduce using rule 13 (loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET block .)
    ELSE            reduce using rule 13 (loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET block .)
    RETURN          reduce using rule 13 (loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET block .)


state 78

    (36) expr -> expr oper_add comp .
    (57) comp -> comp . oper_mult factor_n
    (41) oper_mult -> . MULT
    (42) oper_mult -> . DIV
    (43) oper_mult -> . MOD
    (44) oper_mult -> . AND
    (45) oper_mult -> . OR
    (46) oper_mult -> . XOR
    (47) oper_mult -> . LESSER
    (48) oper_mult -> . GREATER
    (49) oper_mult -> . EQUAL
    (50) oper_mult -> . LESSER_EQ
    (51) oper_mult -> . GREATER_EQ

    CLOSE_BRACKET   reduce using rule 36 (expr -> expr oper_add comp .)
    PLUS            reduce using rule 36 (expr -> expr oper_add comp .)
    MINUS           reduce using rule 36 (expr -> expr oper_add comp .)
    NUMBER          reduce using rule 36 (expr -> expr oper_add comp .)
    STRING_EXPR     reduce using rule 36 (expr -> expr oper_add comp .)
    ID              reduce using rule 36 (expr -> expr oper_add comp .)
    NOT             reduce using rule 36 (expr -> expr oper_add comp .)
    OPEN_BRACKET    reduce using rule 36 (expr -> expr oper_add comp .)
    ENDLINE         reduce using rule 36 (expr -> expr oper_add comp .)
    END             reduce using rule 36 (expr -> expr oper_add comp .)
    ELSE            reduce using rule 36 (expr -> expr oper_add comp .)
    RETURN          reduce using rule 36 (expr -> expr oper_add comp .)
    MULT            shift and go to state 57
    DIV             shift and go to state 58
    MOD             shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    XOR             shift and go to state 62
    LESSER          shift and go to state 63
    GREATER         shift and go to state 64
    EQUAL           shift and go to state 65
    LESSER_EQ       shift and go to state 66
    GREATER_EQ      shift and go to state 67

    oper_mult                      shift and go to state 56

state 79

    (57) comp -> comp oper_mult factor_n .

    MULT            reduce using rule 57 (comp -> comp oper_mult factor_n .)
    DIV             reduce using rule 57 (comp -> comp oper_mult factor_n .)
    MOD             reduce using rule 57 (comp -> comp oper_mult factor_n .)
    AND             reduce using rule 57 (comp -> comp oper_mult factor_n .)
    OR              reduce using rule 57 (comp -> comp oper_mult factor_n .)
    XOR             reduce using rule 57 (comp -> comp oper_mult factor_n .)
    LESSER          reduce using rule 57 (comp -> comp oper_mult factor_n .)
    GREATER         reduce using rule 57 (comp -> comp oper_mult factor_n .)
    EQUAL           reduce using rule 57 (comp -> comp oper_mult factor_n .)
    LESSER_EQ       reduce using rule 57 (comp -> comp oper_mult factor_n .)
    GREATER_EQ      reduce using rule 57 (comp -> comp oper_mult factor_n .)
    CLOSE_BRACKET   reduce using rule 57 (comp -> comp oper_mult factor_n .)
    PLUS            reduce using rule 57 (comp -> comp oper_mult factor_n .)
    MINUS           reduce using rule 57 (comp -> comp oper_mult factor_n .)
    NUMBER          reduce using rule 57 (comp -> comp oper_mult factor_n .)
    STRING_EXPR     reduce using rule 57 (comp -> comp oper_mult factor_n .)
    ID              reduce using rule 57 (comp -> comp oper_mult factor_n .)
    NOT             reduce using rule 57 (comp -> comp oper_mult factor_n .)
    OPEN_BRACKET    reduce using rule 57 (comp -> comp oper_mult factor_n .)
    ENDLINE         reduce using rule 57 (comp -> comp oper_mult factor_n .)
    END             reduce using rule 57 (comp -> comp oper_mult factor_n .)
    ELSE            reduce using rule 57 (comp -> comp oper_mult factor_n .)
    RETURN          reduce using rule 57 (comp -> comp oper_mult factor_n .)


state 80

    (32) if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN . block_body end_if
    (3) block_body -> . lines
    (4) block_body -> . loop
    (5) block_body -> . if_stat
    (6) block_body -> . func_decl
    (7) lines -> . lines line
    (8) lines -> . line
    (13) loop -> . LOOP OPEN_BRACKET expr CLOSE_BRACKET block
    (32) if_stat -> . IF OPEN_BRACKET expr CLOSE_BRACKET THEN block_body end_if
    (14) func_decl -> . FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN block_body RETURN return_val
    (9) line -> . line_body ENDLINE
    (10) line_body -> . var_decl
    (11) line_body -> . func_call
    (12) line_body -> . var_assign
    (18) var_decl -> . type ID ASSIGN value
    (28) func_call -> . ID OPEN_BRACKET values CLOSE_BRACKET
    (19) var_assign -> . ID ASSIGN value
    (26) type -> . INT
    (27) type -> . STRING

    LOOP            shift and go to state 11
    IF              shift and go to state 12
    FUNCTION        shift and go to state 13
    ID              shift and go to state 14
    INT             shift and go to state 20
    STRING          shift and go to state 21

    block_body                     shift and go to state 84
    lines                          shift and go to state 6
    loop                           shift and go to state 7
    if_stat                        shift and go to state 8
    func_decl                      shift and go to state 9
    line                           shift and go to state 10
    line_body                      shift and go to state 15
    var_decl                       shift and go to state 16
    func_call                      shift and go to state 17
    var_assign                     shift and go to state 18
    type                           shift and go to state 19

state 81

    (14) func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET . BEGIN block_body RETURN return_val

    BEGIN           shift and go to state 85


state 82

    (30) args -> args arg .

    CLOSE_BRACKET   reduce using rule 30 (args -> args arg .)
    INT             reduce using rule 30 (args -> args arg .)
    STRING          reduce using rule 30 (args -> args arg .)


state 83

    (29) arg -> type ID .

    CLOSE_BRACKET   reduce using rule 29 (arg -> type ID .)
    INT             reduce using rule 29 (arg -> type ID .)
    STRING          reduce using rule 29 (arg -> type ID .)


state 84

    (32) if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN block_body . end_if
    (33) end_if -> . END
    (34) end_if -> . else_stat
    (35) else_stat -> . ELSE THEN block_body END

    END             shift and go to state 87
    ELSE            shift and go to state 89

    end_if                         shift and go to state 86
    else_stat                      shift and go to state 88

state 85

    (14) func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN . block_body RETURN return_val
    (3) block_body -> . lines
    (4) block_body -> . loop
    (5) block_body -> . if_stat
    (6) block_body -> . func_decl
    (7) lines -> . lines line
    (8) lines -> . line
    (13) loop -> . LOOP OPEN_BRACKET expr CLOSE_BRACKET block
    (32) if_stat -> . IF OPEN_BRACKET expr CLOSE_BRACKET THEN block_body end_if
    (14) func_decl -> . FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN block_body RETURN return_val
    (9) line -> . line_body ENDLINE
    (10) line_body -> . var_decl
    (11) line_body -> . func_call
    (12) line_body -> . var_assign
    (18) var_decl -> . type ID ASSIGN value
    (28) func_call -> . ID OPEN_BRACKET values CLOSE_BRACKET
    (19) var_assign -> . ID ASSIGN value
    (26) type -> . INT
    (27) type -> . STRING

    LOOP            shift and go to state 11
    IF              shift and go to state 12
    FUNCTION        shift and go to state 13
    ID              shift and go to state 14
    INT             shift and go to state 20
    STRING          shift and go to state 21

    block_body                     shift and go to state 90
    lines                          shift and go to state 6
    loop                           shift and go to state 7
    if_stat                        shift and go to state 8
    func_decl                      shift and go to state 9
    line                           shift and go to state 10
    line_body                      shift and go to state 15
    var_decl                       shift and go to state 16
    func_call                      shift and go to state 17
    var_assign                     shift and go to state 18
    type                           shift and go to state 19

state 86

    (32) if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN block_body end_if .

    END             reduce using rule 32 (if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN block_body end_if .)
    ELSE            reduce using rule 32 (if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN block_body end_if .)
    RETURN          reduce using rule 32 (if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN block_body end_if .)


state 87

    (33) end_if -> END .

    END             reduce using rule 33 (end_if -> END .)
    ELSE            reduce using rule 33 (end_if -> END .)
    RETURN          reduce using rule 33 (end_if -> END .)


state 88

    (34) end_if -> else_stat .

    END             reduce using rule 34 (end_if -> else_stat .)
    ELSE            reduce using rule 34 (end_if -> else_stat .)
    RETURN          reduce using rule 34 (end_if -> else_stat .)


state 89

    (35) else_stat -> ELSE . THEN block_body END

    THEN            shift and go to state 91


state 90

    (14) func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN block_body . RETURN return_val

    RETURN          shift and go to state 92


state 91

    (35) else_stat -> ELSE THEN . block_body END
    (3) block_body -> . lines
    (4) block_body -> . loop
    (5) block_body -> . if_stat
    (6) block_body -> . func_decl
    (7) lines -> . lines line
    (8) lines -> . line
    (13) loop -> . LOOP OPEN_BRACKET expr CLOSE_BRACKET block
    (32) if_stat -> . IF OPEN_BRACKET expr CLOSE_BRACKET THEN block_body end_if
    (14) func_decl -> . FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN block_body RETURN return_val
    (9) line -> . line_body ENDLINE
    (10) line_body -> . var_decl
    (11) line_body -> . func_call
    (12) line_body -> . var_assign
    (18) var_decl -> . type ID ASSIGN value
    (28) func_call -> . ID OPEN_BRACKET values CLOSE_BRACKET
    (19) var_assign -> . ID ASSIGN value
    (26) type -> . INT
    (27) type -> . STRING

    LOOP            shift and go to state 11
    IF              shift and go to state 12
    FUNCTION        shift and go to state 13
    ID              shift and go to state 14
    INT             shift and go to state 20
    STRING          shift and go to state 21

    block_body                     shift and go to state 93
    lines                          shift and go to state 6
    loop                           shift and go to state 7
    if_stat                        shift and go to state 8
    func_decl                      shift and go to state 9
    line                           shift and go to state 10
    line_body                      shift and go to state 15
    var_decl                       shift and go to state 16
    func_call                      shift and go to state 17
    var_assign                     shift and go to state 18
    type                           shift and go to state 19

state 92

    (14) func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN block_body RETURN . return_val
    (15) return_val -> . ID
    (16) return_val -> . expr
    (17) return_val -> . func_call
    (36) expr -> . expr oper_add comp
    (37) expr -> . comp
    (28) func_call -> . ID OPEN_BRACKET values CLOSE_BRACKET
    (57) comp -> . comp oper_mult factor_n
    (58) comp -> . factor_n
    (55) factor_n -> . NOT factor
    (56) factor_n -> . factor
    (52) factor -> . ID
    (53) factor -> . NUMBER
    (54) factor -> . brac_expr
    (38) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET

    ID              shift and go to state 94
    NOT             shift and go to state 35
    NUMBER          shift and go to state 38
    OPEN_BRACKET    shift and go to state 31

    return_val                     shift and go to state 95
    expr                           shift and go to state 96
    func_call                      shift and go to state 97
    comp                           shift and go to state 33
    factor_n                       shift and go to state 34
    factor                         shift and go to state 36
    brac_expr                      shift and go to state 39

state 93

    (35) else_stat -> ELSE THEN block_body . END

    END             shift and go to state 98


state 94

    (15) return_val -> ID .
    (28) func_call -> ID . OPEN_BRACKET values CLOSE_BRACKET
    (52) factor -> ID .

  ! reduce/reduce conflict for END resolved using rule 15 (return_val -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 15 (return_val -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 15 (return_val -> ID .)
    END             reduce using rule 15 (return_val -> ID .)
    ELSE            reduce using rule 15 (return_val -> ID .)
    RETURN          reduce using rule 15 (return_val -> ID .)
    OPEN_BRACKET    shift and go to state 27
    MULT            reduce using rule 52 (factor -> ID .)
    DIV             reduce using rule 52 (factor -> ID .)
    MOD             reduce using rule 52 (factor -> ID .)
    AND             reduce using rule 52 (factor -> ID .)
    OR              reduce using rule 52 (factor -> ID .)
    XOR             reduce using rule 52 (factor -> ID .)
    LESSER          reduce using rule 52 (factor -> ID .)
    GREATER         reduce using rule 52 (factor -> ID .)
    EQUAL           reduce using rule 52 (factor -> ID .)
    LESSER_EQ       reduce using rule 52 (factor -> ID .)
    GREATER_EQ      reduce using rule 52 (factor -> ID .)
    PLUS            reduce using rule 52 (factor -> ID .)
    MINUS           reduce using rule 52 (factor -> ID .)

  ! END             [ reduce using rule 52 (factor -> ID .) ]
  ! ELSE            [ reduce using rule 52 (factor -> ID .) ]
  ! RETURN          [ reduce using rule 52 (factor -> ID .) ]


state 95

    (14) func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN block_body RETURN return_val .

    END             reduce using rule 14 (func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN block_body RETURN return_val .)
    ELSE            reduce using rule 14 (func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN block_body RETURN return_val .)
    RETURN          reduce using rule 14 (func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN block_body RETURN return_val .)


state 96

    (16) return_val -> expr .
    (36) expr -> expr . oper_add comp
    (39) oper_add -> . PLUS
    (40) oper_add -> . MINUS

    END             reduce using rule 16 (return_val -> expr .)
    ELSE            reduce using rule 16 (return_val -> expr .)
    RETURN          reduce using rule 16 (return_val -> expr .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55

    oper_add                       shift and go to state 53

state 97

    (17) return_val -> func_call .

    END             reduce using rule 17 (return_val -> func_call .)
    ELSE            reduce using rule 17 (return_val -> func_call .)
    RETURN          reduce using rule 17 (return_val -> func_call .)


state 98

    (35) else_stat -> ELSE THEN block_body END .

    END             reduce using rule 35 (else_stat -> ELSE THEN block_body END .)
    ELSE            reduce using rule 35 (else_stat -> ELSE THEN block_body END .)
    RETURN          reduce using rule 35 (else_stat -> ELSE THEN block_body END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for OPEN_BRACKET in state 42 resolved as shift
WARNING: reduce/reduce conflict in state 45 resolved using rule (value -> NUMBER)
WARNING: rejected rule (factor -> NUMBER) in state 45
WARNING: reduce/reduce conflict in state 94 resolved using rule (return_val -> ID)
WARNING: rejected rule (factor -> ID) in state 94
