Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CLOSE_CURL_BRACKET
    CLOSE_SQ_BRACKET
    ITERABLE_LOOP
    LIST
    NULL
    OPEN_CURL_BRACKET
    OPEN_SQ_BRACKET
    STRING_EXPR

Grammar

Rule 0     S' -> program_decl
Rule 1     program_decl -> PROGRAM block
Rule 2     comment -> COMMENT
Rule 3     block -> BEGIN lines END
Rule 4     lines -> lines line
Rule 5     lines -> line
Rule 6     line -> var_decl
Rule 7     line -> var_assign
Rule 8     line -> if_stat
Rule 9     line -> comment
Rule 10    line -> print
Rule 11    line -> loop
Rule 12    line -> func_decl
Rule 13    loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END
Rule 14    print -> PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE
Rule 15    func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n
Rule 16    var_decl -> type ID ASSIGN factor_n ENDLINE
Rule 17    var_assign -> ID ASSIGN factor_n ENDLINE
Rule 18    type -> INT
Rule 19    type -> STRING
Rule 20    func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET
Rule 21    arg -> type ID
Rule 22    args -> args arg
Rule 23    args -> arg
Rule 24    if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if
Rule 25    end_if -> END
Rule 26    end_if -> else_stat
Rule 27    else_stat -> ELSE THEN lines END
Rule 28    expr -> expr oper_add comp
Rule 29    expr -> comp
Rule 30    brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET
Rule 31    oper_add -> PLUS
Rule 32    oper_add -> MINUS
Rule 33    oper_mult -> MULT
Rule 34    oper_mult -> DIV
Rule 35    oper_mult -> MOD
Rule 36    oper_mult -> AND
Rule 37    oper_mult -> OR
Rule 38    oper_mult -> XOR
Rule 39    oper_mult -> LESSER
Rule 40    oper_mult -> GREATER
Rule 41    oper_mult -> EQUAL
Rule 42    oper_mult -> LESSER_EQ
Rule 43    oper_mult -> GREATER_EQ
Rule 44    oper_mult -> N_EQUAL
Rule 45    factor -> ID
Rule 46    factor -> NUMBER
Rule 47    factor -> brac_expr
Rule 48    factor -> func_call
Rule 49    factor_n -> NOT factor
Rule 50    factor_n -> factor
Rule 51    factors_n -> factor_n
Rule 52    factors_n -> factors_n factor_n
Rule 53    comp -> comp oper_mult factor_n
Rule 54    comp -> factor_n

Terminals, with rules where they appear

AND                  : 36
ASSIGN               : 16 17
BEGIN                : 3 13 15
CLOSE_BRACKET        : 13 14 15 20 24 30
CLOSE_CURL_BRACKET   : 
CLOSE_SQ_BRACKET     : 
COMMENT              : 2
DIV                  : 34
ELSE                 : 27
END                  : 3 13 25 27
ENDLINE              : 14 16 17
EQUAL                : 41
FUNCTION             : 15
GREATER              : 40
GREATER_EQ           : 43
ID                   : 15 16 17 20 21 45
IF                   : 24
INT                  : 18
ITERABLE_LOOP        : 
LESSER               : 39
LESSER_EQ            : 42
LIST                 : 
LOOP                 : 13
MINUS                : 32
MOD                  : 35
MULT                 : 33
NOT                  : 49
NULL                 : 
NUMBER               : 46
N_EQUAL              : 44
OPEN_BRACKET         : 13 14 15 20 24 30
OPEN_CURL_BRACKET    : 
OPEN_SQ_BRACKET      : 
OR                   : 37
PLUS                 : 31
PRINT                : 14
PROGRAM              : 1
RETURN               : 15
STRING               : 19
STRING_EXPR          : 
THEN                 : 24 27
XOR                  : 38
error                : 

Nonterminals, with rules where they appear

arg                  : 22 23
args                 : 15 22
block                : 1
brac_expr            : 47
comment              : 9
comp                 : 28 29 53
else_stat            : 26
end_if               : 24
expr                 : 13 14 24 28 30
factor               : 49 50
factor_n             : 15 16 17 51 52 53 54
factors_n            : 20 52
func_call            : 48
func_decl            : 12
if_stat              : 8
line                 : 4 5
lines                : 3 4 13 15 24 27
loop                 : 11
oper_add             : 28
oper_mult            : 53
print                : 10
program_decl         : 0
type                 : 16 21
var_assign           : 7
var_decl             : 6

Parsing method: LALR

state 0

    (0) S' -> . program_decl
    (1) program_decl -> . PROGRAM block

    PROGRAM         shift and go to state 2

    program_decl                   shift and go to state 1

state 1

    (0) S' -> program_decl .



state 2

    (1) program_decl -> PROGRAM . block
    (3) block -> . BEGIN lines END

    BEGIN           shift and go to state 4

    block                          shift and go to state 3

state 3

    (1) program_decl -> PROGRAM block .

    $end            reduce using rule 1 (program_decl -> PROGRAM block .)


state 4

    (3) block -> BEGIN . lines END
    (4) lines -> . lines line
    (5) lines -> . line
    (6) line -> . var_decl
    (7) line -> . var_assign
    (8) line -> . if_stat
    (9) line -> . comment
    (10) line -> . print
    (11) line -> . loop
    (12) line -> . func_decl
    (16) var_decl -> . type ID ASSIGN factor_n ENDLINE
    (17) var_assign -> . ID ASSIGN factor_n ENDLINE
    (24) if_stat -> . IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if
    (2) comment -> . COMMENT
    (14) print -> . PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE
    (13) loop -> . LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END
    (15) func_decl -> . FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n
    (18) type -> . INT
    (19) type -> . STRING

    ID              shift and go to state 15
    IF              shift and go to state 16
    COMMENT         shift and go to state 17
    PRINT           shift and go to state 18
    LOOP            shift and go to state 19
    FUNCTION        shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22

    lines                          shift and go to state 5
    line                           shift and go to state 6
    var_decl                       shift and go to state 7
    var_assign                     shift and go to state 8
    if_stat                        shift and go to state 9
    comment                        shift and go to state 10
    print                          shift and go to state 11
    loop                           shift and go to state 12
    func_decl                      shift and go to state 13
    type                           shift and go to state 14

state 5

    (3) block -> BEGIN lines . END
    (4) lines -> lines . line
    (6) line -> . var_decl
    (7) line -> . var_assign
    (8) line -> . if_stat
    (9) line -> . comment
    (10) line -> . print
    (11) line -> . loop
    (12) line -> . func_decl
    (16) var_decl -> . type ID ASSIGN factor_n ENDLINE
    (17) var_assign -> . ID ASSIGN factor_n ENDLINE
    (24) if_stat -> . IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if
    (2) comment -> . COMMENT
    (14) print -> . PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE
    (13) loop -> . LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END
    (15) func_decl -> . FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n
    (18) type -> . INT
    (19) type -> . STRING

    END             shift and go to state 23
    ID              shift and go to state 15
    IF              shift and go to state 16
    COMMENT         shift and go to state 17
    PRINT           shift and go to state 18
    LOOP            shift and go to state 19
    FUNCTION        shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22

    line                           shift and go to state 24
    var_decl                       shift and go to state 7
    var_assign                     shift and go to state 8
    if_stat                        shift and go to state 9
    comment                        shift and go to state 10
    print                          shift and go to state 11
    loop                           shift and go to state 12
    func_decl                      shift and go to state 13
    type                           shift and go to state 14

state 6

    (5) lines -> line .

    END             reduce using rule 5 (lines -> line .)
    ID              reduce using rule 5 (lines -> line .)
    IF              reduce using rule 5 (lines -> line .)
    COMMENT         reduce using rule 5 (lines -> line .)
    PRINT           reduce using rule 5 (lines -> line .)
    LOOP            reduce using rule 5 (lines -> line .)
    FUNCTION        reduce using rule 5 (lines -> line .)
    INT             reduce using rule 5 (lines -> line .)
    STRING          reduce using rule 5 (lines -> line .)
    ELSE            reduce using rule 5 (lines -> line .)
    RETURN          reduce using rule 5 (lines -> line .)


state 7

    (6) line -> var_decl .

    END             reduce using rule 6 (line -> var_decl .)
    ID              reduce using rule 6 (line -> var_decl .)
    IF              reduce using rule 6 (line -> var_decl .)
    COMMENT         reduce using rule 6 (line -> var_decl .)
    PRINT           reduce using rule 6 (line -> var_decl .)
    LOOP            reduce using rule 6 (line -> var_decl .)
    FUNCTION        reduce using rule 6 (line -> var_decl .)
    INT             reduce using rule 6 (line -> var_decl .)
    STRING          reduce using rule 6 (line -> var_decl .)
    ELSE            reduce using rule 6 (line -> var_decl .)
    RETURN          reduce using rule 6 (line -> var_decl .)


state 8

    (7) line -> var_assign .

    END             reduce using rule 7 (line -> var_assign .)
    ID              reduce using rule 7 (line -> var_assign .)
    IF              reduce using rule 7 (line -> var_assign .)
    COMMENT         reduce using rule 7 (line -> var_assign .)
    PRINT           reduce using rule 7 (line -> var_assign .)
    LOOP            reduce using rule 7 (line -> var_assign .)
    FUNCTION        reduce using rule 7 (line -> var_assign .)
    INT             reduce using rule 7 (line -> var_assign .)
    STRING          reduce using rule 7 (line -> var_assign .)
    ELSE            reduce using rule 7 (line -> var_assign .)
    RETURN          reduce using rule 7 (line -> var_assign .)


state 9

    (8) line -> if_stat .

    END             reduce using rule 8 (line -> if_stat .)
    ID              reduce using rule 8 (line -> if_stat .)
    IF              reduce using rule 8 (line -> if_stat .)
    COMMENT         reduce using rule 8 (line -> if_stat .)
    PRINT           reduce using rule 8 (line -> if_stat .)
    LOOP            reduce using rule 8 (line -> if_stat .)
    FUNCTION        reduce using rule 8 (line -> if_stat .)
    INT             reduce using rule 8 (line -> if_stat .)
    STRING          reduce using rule 8 (line -> if_stat .)
    ELSE            reduce using rule 8 (line -> if_stat .)
    RETURN          reduce using rule 8 (line -> if_stat .)


state 10

    (9) line -> comment .

    END             reduce using rule 9 (line -> comment .)
    ID              reduce using rule 9 (line -> comment .)
    IF              reduce using rule 9 (line -> comment .)
    COMMENT         reduce using rule 9 (line -> comment .)
    PRINT           reduce using rule 9 (line -> comment .)
    LOOP            reduce using rule 9 (line -> comment .)
    FUNCTION        reduce using rule 9 (line -> comment .)
    INT             reduce using rule 9 (line -> comment .)
    STRING          reduce using rule 9 (line -> comment .)
    ELSE            reduce using rule 9 (line -> comment .)
    RETURN          reduce using rule 9 (line -> comment .)


state 11

    (10) line -> print .

    END             reduce using rule 10 (line -> print .)
    ID              reduce using rule 10 (line -> print .)
    IF              reduce using rule 10 (line -> print .)
    COMMENT         reduce using rule 10 (line -> print .)
    PRINT           reduce using rule 10 (line -> print .)
    LOOP            reduce using rule 10 (line -> print .)
    FUNCTION        reduce using rule 10 (line -> print .)
    INT             reduce using rule 10 (line -> print .)
    STRING          reduce using rule 10 (line -> print .)
    ELSE            reduce using rule 10 (line -> print .)
    RETURN          reduce using rule 10 (line -> print .)


state 12

    (11) line -> loop .

    END             reduce using rule 11 (line -> loop .)
    ID              reduce using rule 11 (line -> loop .)
    IF              reduce using rule 11 (line -> loop .)
    COMMENT         reduce using rule 11 (line -> loop .)
    PRINT           reduce using rule 11 (line -> loop .)
    LOOP            reduce using rule 11 (line -> loop .)
    FUNCTION        reduce using rule 11 (line -> loop .)
    INT             reduce using rule 11 (line -> loop .)
    STRING          reduce using rule 11 (line -> loop .)
    ELSE            reduce using rule 11 (line -> loop .)
    RETURN          reduce using rule 11 (line -> loop .)


state 13

    (12) line -> func_decl .

    END             reduce using rule 12 (line -> func_decl .)
    ID              reduce using rule 12 (line -> func_decl .)
    IF              reduce using rule 12 (line -> func_decl .)
    COMMENT         reduce using rule 12 (line -> func_decl .)
    PRINT           reduce using rule 12 (line -> func_decl .)
    LOOP            reduce using rule 12 (line -> func_decl .)
    FUNCTION        reduce using rule 12 (line -> func_decl .)
    INT             reduce using rule 12 (line -> func_decl .)
    STRING          reduce using rule 12 (line -> func_decl .)
    ELSE            reduce using rule 12 (line -> func_decl .)
    RETURN          reduce using rule 12 (line -> func_decl .)


state 14

    (16) var_decl -> type . ID ASSIGN factor_n ENDLINE

    ID              shift and go to state 25


state 15

    (17) var_assign -> ID . ASSIGN factor_n ENDLINE

    ASSIGN          shift and go to state 26


state 16

    (24) if_stat -> IF . OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if

    OPEN_BRACKET    shift and go to state 27


state 17

    (2) comment -> COMMENT .

    END             reduce using rule 2 (comment -> COMMENT .)
    ID              reduce using rule 2 (comment -> COMMENT .)
    IF              reduce using rule 2 (comment -> COMMENT .)
    COMMENT         reduce using rule 2 (comment -> COMMENT .)
    PRINT           reduce using rule 2 (comment -> COMMENT .)
    LOOP            reduce using rule 2 (comment -> COMMENT .)
    FUNCTION        reduce using rule 2 (comment -> COMMENT .)
    INT             reduce using rule 2 (comment -> COMMENT .)
    STRING          reduce using rule 2 (comment -> COMMENT .)
    ELSE            reduce using rule 2 (comment -> COMMENT .)
    RETURN          reduce using rule 2 (comment -> COMMENT .)


state 18

    (14) print -> PRINT . OPEN_BRACKET expr CLOSE_BRACKET ENDLINE

    OPEN_BRACKET    shift and go to state 28


state 19

    (13) loop -> LOOP . OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END

    OPEN_BRACKET    shift and go to state 29


state 20

    (15) func_decl -> FUNCTION . ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n

    ID              shift and go to state 30


state 21

    (18) type -> INT .

    ID              reduce using rule 18 (type -> INT .)


state 22

    (19) type -> STRING .

    ID              reduce using rule 19 (type -> STRING .)


state 23

    (3) block -> BEGIN lines END .

    $end            reduce using rule 3 (block -> BEGIN lines END .)


state 24

    (4) lines -> lines line .

    END             reduce using rule 4 (lines -> lines line .)
    ID              reduce using rule 4 (lines -> lines line .)
    IF              reduce using rule 4 (lines -> lines line .)
    COMMENT         reduce using rule 4 (lines -> lines line .)
    PRINT           reduce using rule 4 (lines -> lines line .)
    LOOP            reduce using rule 4 (lines -> lines line .)
    FUNCTION        reduce using rule 4 (lines -> lines line .)
    INT             reduce using rule 4 (lines -> lines line .)
    STRING          reduce using rule 4 (lines -> lines line .)
    ELSE            reduce using rule 4 (lines -> lines line .)
    RETURN          reduce using rule 4 (lines -> lines line .)


state 25

    (16) var_decl -> type ID . ASSIGN factor_n ENDLINE

    ASSIGN          shift and go to state 31


state 26

    (17) var_assign -> ID ASSIGN . factor_n ENDLINE
    (49) factor_n -> . NOT factor
    (50) factor_n -> . factor
    (45) factor -> . ID
    (46) factor -> . NUMBER
    (47) factor -> . brac_expr
    (48) factor -> . func_call
    (30) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET
    (20) func_call -> . ID OPEN_BRACKET factors_n CLOSE_BRACKET

    NOT             shift and go to state 34
    ID              shift and go to state 32
    NUMBER          shift and go to state 36
    OPEN_BRACKET    shift and go to state 39

    factor_n                       shift and go to state 33
    factor                         shift and go to state 35
    brac_expr                      shift and go to state 37
    func_call                      shift and go to state 38

state 27

    (24) if_stat -> IF OPEN_BRACKET . expr CLOSE_BRACKET THEN lines end_if
    (28) expr -> . expr oper_add comp
    (29) expr -> . comp
    (53) comp -> . comp oper_mult factor_n
    (54) comp -> . factor_n
    (49) factor_n -> . NOT factor
    (50) factor_n -> . factor
    (45) factor -> . ID
    (46) factor -> . NUMBER
    (47) factor -> . brac_expr
    (48) factor -> . func_call
    (30) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET
    (20) func_call -> . ID OPEN_BRACKET factors_n CLOSE_BRACKET

    NOT             shift and go to state 34
    ID              shift and go to state 32
    NUMBER          shift and go to state 36
    OPEN_BRACKET    shift and go to state 39

    expr                           shift and go to state 40
    comp                           shift and go to state 41
    factor_n                       shift and go to state 42
    factor                         shift and go to state 35
    brac_expr                      shift and go to state 37
    func_call                      shift and go to state 38

state 28

    (14) print -> PRINT OPEN_BRACKET . expr CLOSE_BRACKET ENDLINE
    (28) expr -> . expr oper_add comp
    (29) expr -> . comp
    (53) comp -> . comp oper_mult factor_n
    (54) comp -> . factor_n
    (49) factor_n -> . NOT factor
    (50) factor_n -> . factor
    (45) factor -> . ID
    (46) factor -> . NUMBER
    (47) factor -> . brac_expr
    (48) factor -> . func_call
    (30) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET
    (20) func_call -> . ID OPEN_BRACKET factors_n CLOSE_BRACKET

    NOT             shift and go to state 34
    ID              shift and go to state 32
    NUMBER          shift and go to state 36
    OPEN_BRACKET    shift and go to state 39

    expr                           shift and go to state 43
    comp                           shift and go to state 41
    factor_n                       shift and go to state 42
    factor                         shift and go to state 35
    brac_expr                      shift and go to state 37
    func_call                      shift and go to state 38

state 29

    (13) loop -> LOOP OPEN_BRACKET . expr CLOSE_BRACKET BEGIN lines END
    (28) expr -> . expr oper_add comp
    (29) expr -> . comp
    (53) comp -> . comp oper_mult factor_n
    (54) comp -> . factor_n
    (49) factor_n -> . NOT factor
    (50) factor_n -> . factor
    (45) factor -> . ID
    (46) factor -> . NUMBER
    (47) factor -> . brac_expr
    (48) factor -> . func_call
    (30) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET
    (20) func_call -> . ID OPEN_BRACKET factors_n CLOSE_BRACKET

    NOT             shift and go to state 34
    ID              shift and go to state 32
    NUMBER          shift and go to state 36
    OPEN_BRACKET    shift and go to state 39

    expr                           shift and go to state 44
    comp                           shift and go to state 41
    factor_n                       shift and go to state 42
    factor                         shift and go to state 35
    brac_expr                      shift and go to state 37
    func_call                      shift and go to state 38

state 30

    (15) func_decl -> FUNCTION ID . OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n

    OPEN_BRACKET    shift and go to state 45


state 31

    (16) var_decl -> type ID ASSIGN . factor_n ENDLINE
    (49) factor_n -> . NOT factor
    (50) factor_n -> . factor
    (45) factor -> . ID
    (46) factor -> . NUMBER
    (47) factor -> . brac_expr
    (48) factor -> . func_call
    (30) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET
    (20) func_call -> . ID OPEN_BRACKET factors_n CLOSE_BRACKET

    NOT             shift and go to state 34
    ID              shift and go to state 32
    NUMBER          shift and go to state 36
    OPEN_BRACKET    shift and go to state 39

    factor_n                       shift and go to state 46
    factor                         shift and go to state 35
    brac_expr                      shift and go to state 37
    func_call                      shift and go to state 38

state 32

    (45) factor -> ID .
    (20) func_call -> ID . OPEN_BRACKET factors_n CLOSE_BRACKET

  ! shift/reduce conflict for OPEN_BRACKET resolved as shift
    ENDLINE         reduce using rule 45 (factor -> ID .)
    MULT            reduce using rule 45 (factor -> ID .)
    DIV             reduce using rule 45 (factor -> ID .)
    MOD             reduce using rule 45 (factor -> ID .)
    AND             reduce using rule 45 (factor -> ID .)
    OR              reduce using rule 45 (factor -> ID .)
    XOR             reduce using rule 45 (factor -> ID .)
    LESSER          reduce using rule 45 (factor -> ID .)
    GREATER         reduce using rule 45 (factor -> ID .)
    EQUAL           reduce using rule 45 (factor -> ID .)
    LESSER_EQ       reduce using rule 45 (factor -> ID .)
    GREATER_EQ      reduce using rule 45 (factor -> ID .)
    N_EQUAL         reduce using rule 45 (factor -> ID .)
    CLOSE_BRACKET   reduce using rule 45 (factor -> ID .)
    PLUS            reduce using rule 45 (factor -> ID .)
    MINUS           reduce using rule 45 (factor -> ID .)
    NOT             reduce using rule 45 (factor -> ID .)
    ID              reduce using rule 45 (factor -> ID .)
    NUMBER          reduce using rule 45 (factor -> ID .)
    END             reduce using rule 45 (factor -> ID .)
    IF              reduce using rule 45 (factor -> ID .)
    COMMENT         reduce using rule 45 (factor -> ID .)
    PRINT           reduce using rule 45 (factor -> ID .)
    LOOP            reduce using rule 45 (factor -> ID .)
    FUNCTION        reduce using rule 45 (factor -> ID .)
    INT             reduce using rule 45 (factor -> ID .)
    STRING          reduce using rule 45 (factor -> ID .)
    ELSE            reduce using rule 45 (factor -> ID .)
    RETURN          reduce using rule 45 (factor -> ID .)
    OPEN_BRACKET    shift and go to state 47

  ! OPEN_BRACKET    [ reduce using rule 45 (factor -> ID .) ]


state 33

    (17) var_assign -> ID ASSIGN factor_n . ENDLINE

    ENDLINE         shift and go to state 48


state 34

    (49) factor_n -> NOT . factor
    (45) factor -> . ID
    (46) factor -> . NUMBER
    (47) factor -> . brac_expr
    (48) factor -> . func_call
    (30) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET
    (20) func_call -> . ID OPEN_BRACKET factors_n CLOSE_BRACKET

    ID              shift and go to state 32
    NUMBER          shift and go to state 36
    OPEN_BRACKET    shift and go to state 39

    factor                         shift and go to state 49
    brac_expr                      shift and go to state 37
    func_call                      shift and go to state 38

state 35

    (50) factor_n -> factor .

    ENDLINE         reduce using rule 50 (factor_n -> factor .)
    MULT            reduce using rule 50 (factor_n -> factor .)
    DIV             reduce using rule 50 (factor_n -> factor .)
    MOD             reduce using rule 50 (factor_n -> factor .)
    AND             reduce using rule 50 (factor_n -> factor .)
    OR              reduce using rule 50 (factor_n -> factor .)
    XOR             reduce using rule 50 (factor_n -> factor .)
    LESSER          reduce using rule 50 (factor_n -> factor .)
    GREATER         reduce using rule 50 (factor_n -> factor .)
    EQUAL           reduce using rule 50 (factor_n -> factor .)
    LESSER_EQ       reduce using rule 50 (factor_n -> factor .)
    GREATER_EQ      reduce using rule 50 (factor_n -> factor .)
    N_EQUAL         reduce using rule 50 (factor_n -> factor .)
    CLOSE_BRACKET   reduce using rule 50 (factor_n -> factor .)
    PLUS            reduce using rule 50 (factor_n -> factor .)
    MINUS           reduce using rule 50 (factor_n -> factor .)
    NOT             reduce using rule 50 (factor_n -> factor .)
    ID              reduce using rule 50 (factor_n -> factor .)
    NUMBER          reduce using rule 50 (factor_n -> factor .)
    OPEN_BRACKET    reduce using rule 50 (factor_n -> factor .)
    END             reduce using rule 50 (factor_n -> factor .)
    IF              reduce using rule 50 (factor_n -> factor .)
    COMMENT         reduce using rule 50 (factor_n -> factor .)
    PRINT           reduce using rule 50 (factor_n -> factor .)
    LOOP            reduce using rule 50 (factor_n -> factor .)
    FUNCTION        reduce using rule 50 (factor_n -> factor .)
    INT             reduce using rule 50 (factor_n -> factor .)
    STRING          reduce using rule 50 (factor_n -> factor .)
    ELSE            reduce using rule 50 (factor_n -> factor .)
    RETURN          reduce using rule 50 (factor_n -> factor .)


state 36

    (46) factor -> NUMBER .

    ENDLINE         reduce using rule 46 (factor -> NUMBER .)
    MULT            reduce using rule 46 (factor -> NUMBER .)
    DIV             reduce using rule 46 (factor -> NUMBER .)
    MOD             reduce using rule 46 (factor -> NUMBER .)
    AND             reduce using rule 46 (factor -> NUMBER .)
    OR              reduce using rule 46 (factor -> NUMBER .)
    XOR             reduce using rule 46 (factor -> NUMBER .)
    LESSER          reduce using rule 46 (factor -> NUMBER .)
    GREATER         reduce using rule 46 (factor -> NUMBER .)
    EQUAL           reduce using rule 46 (factor -> NUMBER .)
    LESSER_EQ       reduce using rule 46 (factor -> NUMBER .)
    GREATER_EQ      reduce using rule 46 (factor -> NUMBER .)
    N_EQUAL         reduce using rule 46 (factor -> NUMBER .)
    CLOSE_BRACKET   reduce using rule 46 (factor -> NUMBER .)
    PLUS            reduce using rule 46 (factor -> NUMBER .)
    MINUS           reduce using rule 46 (factor -> NUMBER .)
    NOT             reduce using rule 46 (factor -> NUMBER .)
    ID              reduce using rule 46 (factor -> NUMBER .)
    NUMBER          reduce using rule 46 (factor -> NUMBER .)
    OPEN_BRACKET    reduce using rule 46 (factor -> NUMBER .)
    END             reduce using rule 46 (factor -> NUMBER .)
    IF              reduce using rule 46 (factor -> NUMBER .)
    COMMENT         reduce using rule 46 (factor -> NUMBER .)
    PRINT           reduce using rule 46 (factor -> NUMBER .)
    LOOP            reduce using rule 46 (factor -> NUMBER .)
    FUNCTION        reduce using rule 46 (factor -> NUMBER .)
    INT             reduce using rule 46 (factor -> NUMBER .)
    STRING          reduce using rule 46 (factor -> NUMBER .)
    ELSE            reduce using rule 46 (factor -> NUMBER .)
    RETURN          reduce using rule 46 (factor -> NUMBER .)


state 37

    (47) factor -> brac_expr .

    ENDLINE         reduce using rule 47 (factor -> brac_expr .)
    MULT            reduce using rule 47 (factor -> brac_expr .)
    DIV             reduce using rule 47 (factor -> brac_expr .)
    MOD             reduce using rule 47 (factor -> brac_expr .)
    AND             reduce using rule 47 (factor -> brac_expr .)
    OR              reduce using rule 47 (factor -> brac_expr .)
    XOR             reduce using rule 47 (factor -> brac_expr .)
    LESSER          reduce using rule 47 (factor -> brac_expr .)
    GREATER         reduce using rule 47 (factor -> brac_expr .)
    EQUAL           reduce using rule 47 (factor -> brac_expr .)
    LESSER_EQ       reduce using rule 47 (factor -> brac_expr .)
    GREATER_EQ      reduce using rule 47 (factor -> brac_expr .)
    N_EQUAL         reduce using rule 47 (factor -> brac_expr .)
    CLOSE_BRACKET   reduce using rule 47 (factor -> brac_expr .)
    PLUS            reduce using rule 47 (factor -> brac_expr .)
    MINUS           reduce using rule 47 (factor -> brac_expr .)
    NOT             reduce using rule 47 (factor -> brac_expr .)
    ID              reduce using rule 47 (factor -> brac_expr .)
    NUMBER          reduce using rule 47 (factor -> brac_expr .)
    OPEN_BRACKET    reduce using rule 47 (factor -> brac_expr .)
    END             reduce using rule 47 (factor -> brac_expr .)
    IF              reduce using rule 47 (factor -> brac_expr .)
    COMMENT         reduce using rule 47 (factor -> brac_expr .)
    PRINT           reduce using rule 47 (factor -> brac_expr .)
    LOOP            reduce using rule 47 (factor -> brac_expr .)
    FUNCTION        reduce using rule 47 (factor -> brac_expr .)
    INT             reduce using rule 47 (factor -> brac_expr .)
    STRING          reduce using rule 47 (factor -> brac_expr .)
    ELSE            reduce using rule 47 (factor -> brac_expr .)
    RETURN          reduce using rule 47 (factor -> brac_expr .)


state 38

    (48) factor -> func_call .

    ENDLINE         reduce using rule 48 (factor -> func_call .)
    MULT            reduce using rule 48 (factor -> func_call .)
    DIV             reduce using rule 48 (factor -> func_call .)
    MOD             reduce using rule 48 (factor -> func_call .)
    AND             reduce using rule 48 (factor -> func_call .)
    OR              reduce using rule 48 (factor -> func_call .)
    XOR             reduce using rule 48 (factor -> func_call .)
    LESSER          reduce using rule 48 (factor -> func_call .)
    GREATER         reduce using rule 48 (factor -> func_call .)
    EQUAL           reduce using rule 48 (factor -> func_call .)
    LESSER_EQ       reduce using rule 48 (factor -> func_call .)
    GREATER_EQ      reduce using rule 48 (factor -> func_call .)
    N_EQUAL         reduce using rule 48 (factor -> func_call .)
    CLOSE_BRACKET   reduce using rule 48 (factor -> func_call .)
    PLUS            reduce using rule 48 (factor -> func_call .)
    MINUS           reduce using rule 48 (factor -> func_call .)
    NOT             reduce using rule 48 (factor -> func_call .)
    ID              reduce using rule 48 (factor -> func_call .)
    NUMBER          reduce using rule 48 (factor -> func_call .)
    OPEN_BRACKET    reduce using rule 48 (factor -> func_call .)
    END             reduce using rule 48 (factor -> func_call .)
    IF              reduce using rule 48 (factor -> func_call .)
    COMMENT         reduce using rule 48 (factor -> func_call .)
    PRINT           reduce using rule 48 (factor -> func_call .)
    LOOP            reduce using rule 48 (factor -> func_call .)
    FUNCTION        reduce using rule 48 (factor -> func_call .)
    INT             reduce using rule 48 (factor -> func_call .)
    STRING          reduce using rule 48 (factor -> func_call .)
    ELSE            reduce using rule 48 (factor -> func_call .)
    RETURN          reduce using rule 48 (factor -> func_call .)


state 39

    (30) brac_expr -> OPEN_BRACKET . expr CLOSE_BRACKET
    (28) expr -> . expr oper_add comp
    (29) expr -> . comp
    (53) comp -> . comp oper_mult factor_n
    (54) comp -> . factor_n
    (49) factor_n -> . NOT factor
    (50) factor_n -> . factor
    (45) factor -> . ID
    (46) factor -> . NUMBER
    (47) factor -> . brac_expr
    (48) factor -> . func_call
    (30) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET
    (20) func_call -> . ID OPEN_BRACKET factors_n CLOSE_BRACKET

    NOT             shift and go to state 34
    ID              shift and go to state 32
    NUMBER          shift and go to state 36
    OPEN_BRACKET    shift and go to state 39

    expr                           shift and go to state 50
    comp                           shift and go to state 41
    factor_n                       shift and go to state 42
    factor                         shift and go to state 35
    brac_expr                      shift and go to state 37
    func_call                      shift and go to state 38

state 40

    (24) if_stat -> IF OPEN_BRACKET expr . CLOSE_BRACKET THEN lines end_if
    (28) expr -> expr . oper_add comp
    (31) oper_add -> . PLUS
    (32) oper_add -> . MINUS

    CLOSE_BRACKET   shift and go to state 51
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54

    oper_add                       shift and go to state 52

state 41

    (29) expr -> comp .
    (53) comp -> comp . oper_mult factor_n
    (33) oper_mult -> . MULT
    (34) oper_mult -> . DIV
    (35) oper_mult -> . MOD
    (36) oper_mult -> . AND
    (37) oper_mult -> . OR
    (38) oper_mult -> . XOR
    (39) oper_mult -> . LESSER
    (40) oper_mult -> . GREATER
    (41) oper_mult -> . EQUAL
    (42) oper_mult -> . LESSER_EQ
    (43) oper_mult -> . GREATER_EQ
    (44) oper_mult -> . N_EQUAL

    CLOSE_BRACKET   reduce using rule 29 (expr -> comp .)
    PLUS            reduce using rule 29 (expr -> comp .)
    MINUS           reduce using rule 29 (expr -> comp .)
    MULT            shift and go to state 56
    DIV             shift and go to state 57
    MOD             shift and go to state 58
    AND             shift and go to state 59
    OR              shift and go to state 60
    XOR             shift and go to state 61
    LESSER          shift and go to state 62
    GREATER         shift and go to state 63
    EQUAL           shift and go to state 64
    LESSER_EQ       shift and go to state 65
    GREATER_EQ      shift and go to state 66
    N_EQUAL         shift and go to state 67

    oper_mult                      shift and go to state 55

state 42

    (54) comp -> factor_n .

    MULT            reduce using rule 54 (comp -> factor_n .)
    DIV             reduce using rule 54 (comp -> factor_n .)
    MOD             reduce using rule 54 (comp -> factor_n .)
    AND             reduce using rule 54 (comp -> factor_n .)
    OR              reduce using rule 54 (comp -> factor_n .)
    XOR             reduce using rule 54 (comp -> factor_n .)
    LESSER          reduce using rule 54 (comp -> factor_n .)
    GREATER         reduce using rule 54 (comp -> factor_n .)
    EQUAL           reduce using rule 54 (comp -> factor_n .)
    LESSER_EQ       reduce using rule 54 (comp -> factor_n .)
    GREATER_EQ      reduce using rule 54 (comp -> factor_n .)
    N_EQUAL         reduce using rule 54 (comp -> factor_n .)
    CLOSE_BRACKET   reduce using rule 54 (comp -> factor_n .)
    PLUS            reduce using rule 54 (comp -> factor_n .)
    MINUS           reduce using rule 54 (comp -> factor_n .)


state 43

    (14) print -> PRINT OPEN_BRACKET expr . CLOSE_BRACKET ENDLINE
    (28) expr -> expr . oper_add comp
    (31) oper_add -> . PLUS
    (32) oper_add -> . MINUS

    CLOSE_BRACKET   shift and go to state 68
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54

    oper_add                       shift and go to state 52

state 44

    (13) loop -> LOOP OPEN_BRACKET expr . CLOSE_BRACKET BEGIN lines END
    (28) expr -> expr . oper_add comp
    (31) oper_add -> . PLUS
    (32) oper_add -> . MINUS

    CLOSE_BRACKET   shift and go to state 69
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54

    oper_add                       shift and go to state 52

state 45

    (15) func_decl -> FUNCTION ID OPEN_BRACKET . args CLOSE_BRACKET BEGIN lines RETURN factor_n
    (22) args -> . args arg
    (23) args -> . arg
    (21) arg -> . type ID
    (18) type -> . INT
    (19) type -> . STRING

    INT             shift and go to state 21
    STRING          shift and go to state 22

    args                           shift and go to state 70
    arg                            shift and go to state 71
    type                           shift and go to state 72

state 46

    (16) var_decl -> type ID ASSIGN factor_n . ENDLINE

    ENDLINE         shift and go to state 73


state 47

    (20) func_call -> ID OPEN_BRACKET . factors_n CLOSE_BRACKET
    (51) factors_n -> . factor_n
    (52) factors_n -> . factors_n factor_n
    (49) factor_n -> . NOT factor
    (50) factor_n -> . factor
    (45) factor -> . ID
    (46) factor -> . NUMBER
    (47) factor -> . brac_expr
    (48) factor -> . func_call
    (30) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET
    (20) func_call -> . ID OPEN_BRACKET factors_n CLOSE_BRACKET

    NOT             shift and go to state 34
    ID              shift and go to state 32
    NUMBER          shift and go to state 36
    OPEN_BRACKET    shift and go to state 39

    factors_n                      shift and go to state 74
    factor_n                       shift and go to state 75
    factor                         shift and go to state 35
    brac_expr                      shift and go to state 37
    func_call                      shift and go to state 38

state 48

    (17) var_assign -> ID ASSIGN factor_n ENDLINE .

    END             reduce using rule 17 (var_assign -> ID ASSIGN factor_n ENDLINE .)
    ID              reduce using rule 17 (var_assign -> ID ASSIGN factor_n ENDLINE .)
    IF              reduce using rule 17 (var_assign -> ID ASSIGN factor_n ENDLINE .)
    COMMENT         reduce using rule 17 (var_assign -> ID ASSIGN factor_n ENDLINE .)
    PRINT           reduce using rule 17 (var_assign -> ID ASSIGN factor_n ENDLINE .)
    LOOP            reduce using rule 17 (var_assign -> ID ASSIGN factor_n ENDLINE .)
    FUNCTION        reduce using rule 17 (var_assign -> ID ASSIGN factor_n ENDLINE .)
    INT             reduce using rule 17 (var_assign -> ID ASSIGN factor_n ENDLINE .)
    STRING          reduce using rule 17 (var_assign -> ID ASSIGN factor_n ENDLINE .)
    ELSE            reduce using rule 17 (var_assign -> ID ASSIGN factor_n ENDLINE .)
    RETURN          reduce using rule 17 (var_assign -> ID ASSIGN factor_n ENDLINE .)


state 49

    (49) factor_n -> NOT factor .

    ENDLINE         reduce using rule 49 (factor_n -> NOT factor .)
    MULT            reduce using rule 49 (factor_n -> NOT factor .)
    DIV             reduce using rule 49 (factor_n -> NOT factor .)
    MOD             reduce using rule 49 (factor_n -> NOT factor .)
    AND             reduce using rule 49 (factor_n -> NOT factor .)
    OR              reduce using rule 49 (factor_n -> NOT factor .)
    XOR             reduce using rule 49 (factor_n -> NOT factor .)
    LESSER          reduce using rule 49 (factor_n -> NOT factor .)
    GREATER         reduce using rule 49 (factor_n -> NOT factor .)
    EQUAL           reduce using rule 49 (factor_n -> NOT factor .)
    LESSER_EQ       reduce using rule 49 (factor_n -> NOT factor .)
    GREATER_EQ      reduce using rule 49 (factor_n -> NOT factor .)
    N_EQUAL         reduce using rule 49 (factor_n -> NOT factor .)
    CLOSE_BRACKET   reduce using rule 49 (factor_n -> NOT factor .)
    PLUS            reduce using rule 49 (factor_n -> NOT factor .)
    MINUS           reduce using rule 49 (factor_n -> NOT factor .)
    NOT             reduce using rule 49 (factor_n -> NOT factor .)
    ID              reduce using rule 49 (factor_n -> NOT factor .)
    NUMBER          reduce using rule 49 (factor_n -> NOT factor .)
    OPEN_BRACKET    reduce using rule 49 (factor_n -> NOT factor .)
    END             reduce using rule 49 (factor_n -> NOT factor .)
    IF              reduce using rule 49 (factor_n -> NOT factor .)
    COMMENT         reduce using rule 49 (factor_n -> NOT factor .)
    PRINT           reduce using rule 49 (factor_n -> NOT factor .)
    LOOP            reduce using rule 49 (factor_n -> NOT factor .)
    FUNCTION        reduce using rule 49 (factor_n -> NOT factor .)
    INT             reduce using rule 49 (factor_n -> NOT factor .)
    STRING          reduce using rule 49 (factor_n -> NOT factor .)
    ELSE            reduce using rule 49 (factor_n -> NOT factor .)
    RETURN          reduce using rule 49 (factor_n -> NOT factor .)


state 50

    (30) brac_expr -> OPEN_BRACKET expr . CLOSE_BRACKET
    (28) expr -> expr . oper_add comp
    (31) oper_add -> . PLUS
    (32) oper_add -> . MINUS

    CLOSE_BRACKET   shift and go to state 76
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54

    oper_add                       shift and go to state 52

state 51

    (24) if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET . THEN lines end_if

    THEN            shift and go to state 77


state 52

    (28) expr -> expr oper_add . comp
    (53) comp -> . comp oper_mult factor_n
    (54) comp -> . factor_n
    (49) factor_n -> . NOT factor
    (50) factor_n -> . factor
    (45) factor -> . ID
    (46) factor -> . NUMBER
    (47) factor -> . brac_expr
    (48) factor -> . func_call
    (30) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET
    (20) func_call -> . ID OPEN_BRACKET factors_n CLOSE_BRACKET

    NOT             shift and go to state 34
    ID              shift and go to state 32
    NUMBER          shift and go to state 36
    OPEN_BRACKET    shift and go to state 39

    comp                           shift and go to state 78
    factor_n                       shift and go to state 42
    factor                         shift and go to state 35
    brac_expr                      shift and go to state 37
    func_call                      shift and go to state 38

state 53

    (31) oper_add -> PLUS .

    NOT             reduce using rule 31 (oper_add -> PLUS .)
    ID              reduce using rule 31 (oper_add -> PLUS .)
    NUMBER          reduce using rule 31 (oper_add -> PLUS .)
    OPEN_BRACKET    reduce using rule 31 (oper_add -> PLUS .)


state 54

    (32) oper_add -> MINUS .

    NOT             reduce using rule 32 (oper_add -> MINUS .)
    ID              reduce using rule 32 (oper_add -> MINUS .)
    NUMBER          reduce using rule 32 (oper_add -> MINUS .)
    OPEN_BRACKET    reduce using rule 32 (oper_add -> MINUS .)


state 55

    (53) comp -> comp oper_mult . factor_n
    (49) factor_n -> . NOT factor
    (50) factor_n -> . factor
    (45) factor -> . ID
    (46) factor -> . NUMBER
    (47) factor -> . brac_expr
    (48) factor -> . func_call
    (30) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET
    (20) func_call -> . ID OPEN_BRACKET factors_n CLOSE_BRACKET

    NOT             shift and go to state 34
    ID              shift and go to state 32
    NUMBER          shift and go to state 36
    OPEN_BRACKET    shift and go to state 39

    factor_n                       shift and go to state 79
    factor                         shift and go to state 35
    brac_expr                      shift and go to state 37
    func_call                      shift and go to state 38

state 56

    (33) oper_mult -> MULT .

    NOT             reduce using rule 33 (oper_mult -> MULT .)
    ID              reduce using rule 33 (oper_mult -> MULT .)
    NUMBER          reduce using rule 33 (oper_mult -> MULT .)
    OPEN_BRACKET    reduce using rule 33 (oper_mult -> MULT .)


state 57

    (34) oper_mult -> DIV .

    NOT             reduce using rule 34 (oper_mult -> DIV .)
    ID              reduce using rule 34 (oper_mult -> DIV .)
    NUMBER          reduce using rule 34 (oper_mult -> DIV .)
    OPEN_BRACKET    reduce using rule 34 (oper_mult -> DIV .)


state 58

    (35) oper_mult -> MOD .

    NOT             reduce using rule 35 (oper_mult -> MOD .)
    ID              reduce using rule 35 (oper_mult -> MOD .)
    NUMBER          reduce using rule 35 (oper_mult -> MOD .)
    OPEN_BRACKET    reduce using rule 35 (oper_mult -> MOD .)


state 59

    (36) oper_mult -> AND .

    NOT             reduce using rule 36 (oper_mult -> AND .)
    ID              reduce using rule 36 (oper_mult -> AND .)
    NUMBER          reduce using rule 36 (oper_mult -> AND .)
    OPEN_BRACKET    reduce using rule 36 (oper_mult -> AND .)


state 60

    (37) oper_mult -> OR .

    NOT             reduce using rule 37 (oper_mult -> OR .)
    ID              reduce using rule 37 (oper_mult -> OR .)
    NUMBER          reduce using rule 37 (oper_mult -> OR .)
    OPEN_BRACKET    reduce using rule 37 (oper_mult -> OR .)


state 61

    (38) oper_mult -> XOR .

    NOT             reduce using rule 38 (oper_mult -> XOR .)
    ID              reduce using rule 38 (oper_mult -> XOR .)
    NUMBER          reduce using rule 38 (oper_mult -> XOR .)
    OPEN_BRACKET    reduce using rule 38 (oper_mult -> XOR .)


state 62

    (39) oper_mult -> LESSER .

    NOT             reduce using rule 39 (oper_mult -> LESSER .)
    ID              reduce using rule 39 (oper_mult -> LESSER .)
    NUMBER          reduce using rule 39 (oper_mult -> LESSER .)
    OPEN_BRACKET    reduce using rule 39 (oper_mult -> LESSER .)


state 63

    (40) oper_mult -> GREATER .

    NOT             reduce using rule 40 (oper_mult -> GREATER .)
    ID              reduce using rule 40 (oper_mult -> GREATER .)
    NUMBER          reduce using rule 40 (oper_mult -> GREATER .)
    OPEN_BRACKET    reduce using rule 40 (oper_mult -> GREATER .)


state 64

    (41) oper_mult -> EQUAL .

    NOT             reduce using rule 41 (oper_mult -> EQUAL .)
    ID              reduce using rule 41 (oper_mult -> EQUAL .)
    NUMBER          reduce using rule 41 (oper_mult -> EQUAL .)
    OPEN_BRACKET    reduce using rule 41 (oper_mult -> EQUAL .)


state 65

    (42) oper_mult -> LESSER_EQ .

    NOT             reduce using rule 42 (oper_mult -> LESSER_EQ .)
    ID              reduce using rule 42 (oper_mult -> LESSER_EQ .)
    NUMBER          reduce using rule 42 (oper_mult -> LESSER_EQ .)
    OPEN_BRACKET    reduce using rule 42 (oper_mult -> LESSER_EQ .)


state 66

    (43) oper_mult -> GREATER_EQ .

    NOT             reduce using rule 43 (oper_mult -> GREATER_EQ .)
    ID              reduce using rule 43 (oper_mult -> GREATER_EQ .)
    NUMBER          reduce using rule 43 (oper_mult -> GREATER_EQ .)
    OPEN_BRACKET    reduce using rule 43 (oper_mult -> GREATER_EQ .)


state 67

    (44) oper_mult -> N_EQUAL .

    NOT             reduce using rule 44 (oper_mult -> N_EQUAL .)
    ID              reduce using rule 44 (oper_mult -> N_EQUAL .)
    NUMBER          reduce using rule 44 (oper_mult -> N_EQUAL .)
    OPEN_BRACKET    reduce using rule 44 (oper_mult -> N_EQUAL .)


state 68

    (14) print -> PRINT OPEN_BRACKET expr CLOSE_BRACKET . ENDLINE

    ENDLINE         shift and go to state 80


state 69

    (13) loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET . BEGIN lines END

    BEGIN           shift and go to state 81


state 70

    (15) func_decl -> FUNCTION ID OPEN_BRACKET args . CLOSE_BRACKET BEGIN lines RETURN factor_n
    (22) args -> args . arg
    (21) arg -> . type ID
    (18) type -> . INT
    (19) type -> . STRING

    CLOSE_BRACKET   shift and go to state 82
    INT             shift and go to state 21
    STRING          shift and go to state 22

    arg                            shift and go to state 83
    type                           shift and go to state 72

state 71

    (23) args -> arg .

    CLOSE_BRACKET   reduce using rule 23 (args -> arg .)
    INT             reduce using rule 23 (args -> arg .)
    STRING          reduce using rule 23 (args -> arg .)


state 72

    (21) arg -> type . ID

    ID              shift and go to state 84


state 73

    (16) var_decl -> type ID ASSIGN factor_n ENDLINE .

    END             reduce using rule 16 (var_decl -> type ID ASSIGN factor_n ENDLINE .)
    ID              reduce using rule 16 (var_decl -> type ID ASSIGN factor_n ENDLINE .)
    IF              reduce using rule 16 (var_decl -> type ID ASSIGN factor_n ENDLINE .)
    COMMENT         reduce using rule 16 (var_decl -> type ID ASSIGN factor_n ENDLINE .)
    PRINT           reduce using rule 16 (var_decl -> type ID ASSIGN factor_n ENDLINE .)
    LOOP            reduce using rule 16 (var_decl -> type ID ASSIGN factor_n ENDLINE .)
    FUNCTION        reduce using rule 16 (var_decl -> type ID ASSIGN factor_n ENDLINE .)
    INT             reduce using rule 16 (var_decl -> type ID ASSIGN factor_n ENDLINE .)
    STRING          reduce using rule 16 (var_decl -> type ID ASSIGN factor_n ENDLINE .)
    ELSE            reduce using rule 16 (var_decl -> type ID ASSIGN factor_n ENDLINE .)
    RETURN          reduce using rule 16 (var_decl -> type ID ASSIGN factor_n ENDLINE .)


state 74

    (20) func_call -> ID OPEN_BRACKET factors_n . CLOSE_BRACKET
    (52) factors_n -> factors_n . factor_n
    (49) factor_n -> . NOT factor
    (50) factor_n -> . factor
    (45) factor -> . ID
    (46) factor -> . NUMBER
    (47) factor -> . brac_expr
    (48) factor -> . func_call
    (30) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET
    (20) func_call -> . ID OPEN_BRACKET factors_n CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 85
    NOT             shift and go to state 34
    ID              shift and go to state 32
    NUMBER          shift and go to state 36
    OPEN_BRACKET    shift and go to state 39

    factor_n                       shift and go to state 86
    factor                         shift and go to state 35
    brac_expr                      shift and go to state 37
    func_call                      shift and go to state 38

state 75

    (51) factors_n -> factor_n .

    CLOSE_BRACKET   reduce using rule 51 (factors_n -> factor_n .)
    NOT             reduce using rule 51 (factors_n -> factor_n .)
    ID              reduce using rule 51 (factors_n -> factor_n .)
    NUMBER          reduce using rule 51 (factors_n -> factor_n .)
    OPEN_BRACKET    reduce using rule 51 (factors_n -> factor_n .)


state 76

    (30) brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .

    ENDLINE         reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    MULT            reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    DIV             reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    MOD             reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    AND             reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    OR              reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    XOR             reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    LESSER          reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    GREATER         reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    EQUAL           reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    LESSER_EQ       reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    GREATER_EQ      reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    N_EQUAL         reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    PLUS            reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    MINUS           reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    NOT             reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    ID              reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    NUMBER          reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    END             reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    IF              reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    COMMENT         reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    PRINT           reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    LOOP            reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    FUNCTION        reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    INT             reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    STRING          reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    ELSE            reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)
    RETURN          reduce using rule 30 (brac_expr -> OPEN_BRACKET expr CLOSE_BRACKET .)


state 77

    (24) if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN . lines end_if
    (4) lines -> . lines line
    (5) lines -> . line
    (6) line -> . var_decl
    (7) line -> . var_assign
    (8) line -> . if_stat
    (9) line -> . comment
    (10) line -> . print
    (11) line -> . loop
    (12) line -> . func_decl
    (16) var_decl -> . type ID ASSIGN factor_n ENDLINE
    (17) var_assign -> . ID ASSIGN factor_n ENDLINE
    (24) if_stat -> . IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if
    (2) comment -> . COMMENT
    (14) print -> . PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE
    (13) loop -> . LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END
    (15) func_decl -> . FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n
    (18) type -> . INT
    (19) type -> . STRING

    ID              shift and go to state 15
    IF              shift and go to state 16
    COMMENT         shift and go to state 17
    PRINT           shift and go to state 18
    LOOP            shift and go to state 19
    FUNCTION        shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22

    lines                          shift and go to state 87
    line                           shift and go to state 6
    var_decl                       shift and go to state 7
    var_assign                     shift and go to state 8
    if_stat                        shift and go to state 9
    comment                        shift and go to state 10
    print                          shift and go to state 11
    loop                           shift and go to state 12
    func_decl                      shift and go to state 13
    type                           shift and go to state 14

state 78

    (28) expr -> expr oper_add comp .
    (53) comp -> comp . oper_mult factor_n
    (33) oper_mult -> . MULT
    (34) oper_mult -> . DIV
    (35) oper_mult -> . MOD
    (36) oper_mult -> . AND
    (37) oper_mult -> . OR
    (38) oper_mult -> . XOR
    (39) oper_mult -> . LESSER
    (40) oper_mult -> . GREATER
    (41) oper_mult -> . EQUAL
    (42) oper_mult -> . LESSER_EQ
    (43) oper_mult -> . GREATER_EQ
    (44) oper_mult -> . N_EQUAL

    CLOSE_BRACKET   reduce using rule 28 (expr -> expr oper_add comp .)
    PLUS            reduce using rule 28 (expr -> expr oper_add comp .)
    MINUS           reduce using rule 28 (expr -> expr oper_add comp .)
    MULT            shift and go to state 56
    DIV             shift and go to state 57
    MOD             shift and go to state 58
    AND             shift and go to state 59
    OR              shift and go to state 60
    XOR             shift and go to state 61
    LESSER          shift and go to state 62
    GREATER         shift and go to state 63
    EQUAL           shift and go to state 64
    LESSER_EQ       shift and go to state 65
    GREATER_EQ      shift and go to state 66
    N_EQUAL         shift and go to state 67

    oper_mult                      shift and go to state 55

state 79

    (53) comp -> comp oper_mult factor_n .

    MULT            reduce using rule 53 (comp -> comp oper_mult factor_n .)
    DIV             reduce using rule 53 (comp -> comp oper_mult factor_n .)
    MOD             reduce using rule 53 (comp -> comp oper_mult factor_n .)
    AND             reduce using rule 53 (comp -> comp oper_mult factor_n .)
    OR              reduce using rule 53 (comp -> comp oper_mult factor_n .)
    XOR             reduce using rule 53 (comp -> comp oper_mult factor_n .)
    LESSER          reduce using rule 53 (comp -> comp oper_mult factor_n .)
    GREATER         reduce using rule 53 (comp -> comp oper_mult factor_n .)
    EQUAL           reduce using rule 53 (comp -> comp oper_mult factor_n .)
    LESSER_EQ       reduce using rule 53 (comp -> comp oper_mult factor_n .)
    GREATER_EQ      reduce using rule 53 (comp -> comp oper_mult factor_n .)
    N_EQUAL         reduce using rule 53 (comp -> comp oper_mult factor_n .)
    CLOSE_BRACKET   reduce using rule 53 (comp -> comp oper_mult factor_n .)
    PLUS            reduce using rule 53 (comp -> comp oper_mult factor_n .)
    MINUS           reduce using rule 53 (comp -> comp oper_mult factor_n .)


state 80

    (14) print -> PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE .

    END             reduce using rule 14 (print -> PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE .)
    ID              reduce using rule 14 (print -> PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE .)
    IF              reduce using rule 14 (print -> PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE .)
    COMMENT         reduce using rule 14 (print -> PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE .)
    PRINT           reduce using rule 14 (print -> PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE .)
    LOOP            reduce using rule 14 (print -> PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE .)
    FUNCTION        reduce using rule 14 (print -> PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE .)
    INT             reduce using rule 14 (print -> PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE .)
    STRING          reduce using rule 14 (print -> PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE .)
    ELSE            reduce using rule 14 (print -> PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE .)
    RETURN          reduce using rule 14 (print -> PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE .)


state 81

    (13) loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN . lines END
    (4) lines -> . lines line
    (5) lines -> . line
    (6) line -> . var_decl
    (7) line -> . var_assign
    (8) line -> . if_stat
    (9) line -> . comment
    (10) line -> . print
    (11) line -> . loop
    (12) line -> . func_decl
    (16) var_decl -> . type ID ASSIGN factor_n ENDLINE
    (17) var_assign -> . ID ASSIGN factor_n ENDLINE
    (24) if_stat -> . IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if
    (2) comment -> . COMMENT
    (14) print -> . PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE
    (13) loop -> . LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END
    (15) func_decl -> . FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n
    (18) type -> . INT
    (19) type -> . STRING

    ID              shift and go to state 15
    IF              shift and go to state 16
    COMMENT         shift and go to state 17
    PRINT           shift and go to state 18
    LOOP            shift and go to state 19
    FUNCTION        shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22

    lines                          shift and go to state 88
    line                           shift and go to state 6
    var_decl                       shift and go to state 7
    var_assign                     shift and go to state 8
    if_stat                        shift and go to state 9
    comment                        shift and go to state 10
    print                          shift and go to state 11
    loop                           shift and go to state 12
    func_decl                      shift and go to state 13
    type                           shift and go to state 14

state 82

    (15) func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET . BEGIN lines RETURN factor_n

    BEGIN           shift and go to state 89


state 83

    (22) args -> args arg .

    CLOSE_BRACKET   reduce using rule 22 (args -> args arg .)
    INT             reduce using rule 22 (args -> args arg .)
    STRING          reduce using rule 22 (args -> args arg .)


state 84

    (21) arg -> type ID .

    CLOSE_BRACKET   reduce using rule 21 (arg -> type ID .)
    INT             reduce using rule 21 (arg -> type ID .)
    STRING          reduce using rule 21 (arg -> type ID .)


state 85

    (20) func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .

    ENDLINE         reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    MULT            reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    DIV             reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    MOD             reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    AND             reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    OR              reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    XOR             reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    LESSER          reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    GREATER         reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    EQUAL           reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    LESSER_EQ       reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    GREATER_EQ      reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    N_EQUAL         reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    PLUS            reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    MINUS           reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    NOT             reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    ID              reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    NUMBER          reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    END             reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    IF              reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    COMMENT         reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    PRINT           reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    LOOP            reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    FUNCTION        reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    INT             reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    STRING          reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    ELSE            reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)
    RETURN          reduce using rule 20 (func_call -> ID OPEN_BRACKET factors_n CLOSE_BRACKET .)


state 86

    (52) factors_n -> factors_n factor_n .

    CLOSE_BRACKET   reduce using rule 52 (factors_n -> factors_n factor_n .)
    NOT             reduce using rule 52 (factors_n -> factors_n factor_n .)
    ID              reduce using rule 52 (factors_n -> factors_n factor_n .)
    NUMBER          reduce using rule 52 (factors_n -> factors_n factor_n .)
    OPEN_BRACKET    reduce using rule 52 (factors_n -> factors_n factor_n .)


state 87

    (24) if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines . end_if
    (4) lines -> lines . line
    (25) end_if -> . END
    (26) end_if -> . else_stat
    (6) line -> . var_decl
    (7) line -> . var_assign
    (8) line -> . if_stat
    (9) line -> . comment
    (10) line -> . print
    (11) line -> . loop
    (12) line -> . func_decl
    (27) else_stat -> . ELSE THEN lines END
    (16) var_decl -> . type ID ASSIGN factor_n ENDLINE
    (17) var_assign -> . ID ASSIGN factor_n ENDLINE
    (24) if_stat -> . IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if
    (2) comment -> . COMMENT
    (14) print -> . PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE
    (13) loop -> . LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END
    (15) func_decl -> . FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n
    (18) type -> . INT
    (19) type -> . STRING

    END             shift and go to state 91
    ELSE            shift and go to state 93
    ID              shift and go to state 15
    IF              shift and go to state 16
    COMMENT         shift and go to state 17
    PRINT           shift and go to state 18
    LOOP            shift and go to state 19
    FUNCTION        shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22

    end_if                         shift and go to state 90
    line                           shift and go to state 24
    else_stat                      shift and go to state 92
    var_decl                       shift and go to state 7
    var_assign                     shift and go to state 8
    if_stat                        shift and go to state 9
    comment                        shift and go to state 10
    print                          shift and go to state 11
    loop                           shift and go to state 12
    func_decl                      shift and go to state 13
    type                           shift and go to state 14

state 88

    (13) loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines . END
    (4) lines -> lines . line
    (6) line -> . var_decl
    (7) line -> . var_assign
    (8) line -> . if_stat
    (9) line -> . comment
    (10) line -> . print
    (11) line -> . loop
    (12) line -> . func_decl
    (16) var_decl -> . type ID ASSIGN factor_n ENDLINE
    (17) var_assign -> . ID ASSIGN factor_n ENDLINE
    (24) if_stat -> . IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if
    (2) comment -> . COMMENT
    (14) print -> . PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE
    (13) loop -> . LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END
    (15) func_decl -> . FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n
    (18) type -> . INT
    (19) type -> . STRING

    END             shift and go to state 94
    ID              shift and go to state 15
    IF              shift and go to state 16
    COMMENT         shift and go to state 17
    PRINT           shift and go to state 18
    LOOP            shift and go to state 19
    FUNCTION        shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22

    line                           shift and go to state 24
    var_decl                       shift and go to state 7
    var_assign                     shift and go to state 8
    if_stat                        shift and go to state 9
    comment                        shift and go to state 10
    print                          shift and go to state 11
    loop                           shift and go to state 12
    func_decl                      shift and go to state 13
    type                           shift and go to state 14

state 89

    (15) func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN . lines RETURN factor_n
    (4) lines -> . lines line
    (5) lines -> . line
    (6) line -> . var_decl
    (7) line -> . var_assign
    (8) line -> . if_stat
    (9) line -> . comment
    (10) line -> . print
    (11) line -> . loop
    (12) line -> . func_decl
    (16) var_decl -> . type ID ASSIGN factor_n ENDLINE
    (17) var_assign -> . ID ASSIGN factor_n ENDLINE
    (24) if_stat -> . IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if
    (2) comment -> . COMMENT
    (14) print -> . PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE
    (13) loop -> . LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END
    (15) func_decl -> . FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n
    (18) type -> . INT
    (19) type -> . STRING

    ID              shift and go to state 15
    IF              shift and go to state 16
    COMMENT         shift and go to state 17
    PRINT           shift and go to state 18
    LOOP            shift and go to state 19
    FUNCTION        shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22

    lines                          shift and go to state 95
    line                           shift and go to state 6
    var_decl                       shift and go to state 7
    var_assign                     shift and go to state 8
    if_stat                        shift and go to state 9
    comment                        shift and go to state 10
    print                          shift and go to state 11
    loop                           shift and go to state 12
    func_decl                      shift and go to state 13
    type                           shift and go to state 14

state 90

    (24) if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if .

    END             reduce using rule 24 (if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if .)
    ID              reduce using rule 24 (if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if .)
    IF              reduce using rule 24 (if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if .)
    COMMENT         reduce using rule 24 (if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if .)
    PRINT           reduce using rule 24 (if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if .)
    LOOP            reduce using rule 24 (if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if .)
    FUNCTION        reduce using rule 24 (if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if .)
    INT             reduce using rule 24 (if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if .)
    STRING          reduce using rule 24 (if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if .)
    ELSE            reduce using rule 24 (if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if .)
    RETURN          reduce using rule 24 (if_stat -> IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if .)


state 91

    (25) end_if -> END .

    END             reduce using rule 25 (end_if -> END .)
    ID              reduce using rule 25 (end_if -> END .)
    IF              reduce using rule 25 (end_if -> END .)
    COMMENT         reduce using rule 25 (end_if -> END .)
    PRINT           reduce using rule 25 (end_if -> END .)
    LOOP            reduce using rule 25 (end_if -> END .)
    FUNCTION        reduce using rule 25 (end_if -> END .)
    INT             reduce using rule 25 (end_if -> END .)
    STRING          reduce using rule 25 (end_if -> END .)
    ELSE            reduce using rule 25 (end_if -> END .)
    RETURN          reduce using rule 25 (end_if -> END .)


state 92

    (26) end_if -> else_stat .

    END             reduce using rule 26 (end_if -> else_stat .)
    ID              reduce using rule 26 (end_if -> else_stat .)
    IF              reduce using rule 26 (end_if -> else_stat .)
    COMMENT         reduce using rule 26 (end_if -> else_stat .)
    PRINT           reduce using rule 26 (end_if -> else_stat .)
    LOOP            reduce using rule 26 (end_if -> else_stat .)
    FUNCTION        reduce using rule 26 (end_if -> else_stat .)
    INT             reduce using rule 26 (end_if -> else_stat .)
    STRING          reduce using rule 26 (end_if -> else_stat .)
    ELSE            reduce using rule 26 (end_if -> else_stat .)
    RETURN          reduce using rule 26 (end_if -> else_stat .)


state 93

    (27) else_stat -> ELSE . THEN lines END

    THEN            shift and go to state 96


state 94

    (13) loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END .

    END             reduce using rule 13 (loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END .)
    ID              reduce using rule 13 (loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END .)
    IF              reduce using rule 13 (loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END .)
    COMMENT         reduce using rule 13 (loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END .)
    PRINT           reduce using rule 13 (loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END .)
    LOOP            reduce using rule 13 (loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END .)
    FUNCTION        reduce using rule 13 (loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END .)
    INT             reduce using rule 13 (loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END .)
    STRING          reduce using rule 13 (loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END .)
    ELSE            reduce using rule 13 (loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END .)
    RETURN          reduce using rule 13 (loop -> LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END .)


state 95

    (15) func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines . RETURN factor_n
    (4) lines -> lines . line
    (6) line -> . var_decl
    (7) line -> . var_assign
    (8) line -> . if_stat
    (9) line -> . comment
    (10) line -> . print
    (11) line -> . loop
    (12) line -> . func_decl
    (16) var_decl -> . type ID ASSIGN factor_n ENDLINE
    (17) var_assign -> . ID ASSIGN factor_n ENDLINE
    (24) if_stat -> . IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if
    (2) comment -> . COMMENT
    (14) print -> . PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE
    (13) loop -> . LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END
    (15) func_decl -> . FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n
    (18) type -> . INT
    (19) type -> . STRING

    RETURN          shift and go to state 97
    ID              shift and go to state 15
    IF              shift and go to state 16
    COMMENT         shift and go to state 17
    PRINT           shift and go to state 18
    LOOP            shift and go to state 19
    FUNCTION        shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22

    line                           shift and go to state 24
    var_decl                       shift and go to state 7
    var_assign                     shift and go to state 8
    if_stat                        shift and go to state 9
    comment                        shift and go to state 10
    print                          shift and go to state 11
    loop                           shift and go to state 12
    func_decl                      shift and go to state 13
    type                           shift and go to state 14

state 96

    (27) else_stat -> ELSE THEN . lines END
    (4) lines -> . lines line
    (5) lines -> . line
    (6) line -> . var_decl
    (7) line -> . var_assign
    (8) line -> . if_stat
    (9) line -> . comment
    (10) line -> . print
    (11) line -> . loop
    (12) line -> . func_decl
    (16) var_decl -> . type ID ASSIGN factor_n ENDLINE
    (17) var_assign -> . ID ASSIGN factor_n ENDLINE
    (24) if_stat -> . IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if
    (2) comment -> . COMMENT
    (14) print -> . PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE
    (13) loop -> . LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END
    (15) func_decl -> . FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n
    (18) type -> . INT
    (19) type -> . STRING

    ID              shift and go to state 15
    IF              shift and go to state 16
    COMMENT         shift and go to state 17
    PRINT           shift and go to state 18
    LOOP            shift and go to state 19
    FUNCTION        shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22

    lines                          shift and go to state 98
    line                           shift and go to state 6
    var_decl                       shift and go to state 7
    var_assign                     shift and go to state 8
    if_stat                        shift and go to state 9
    comment                        shift and go to state 10
    print                          shift and go to state 11
    loop                           shift and go to state 12
    func_decl                      shift and go to state 13
    type                           shift and go to state 14

state 97

    (15) func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN . factor_n
    (49) factor_n -> . NOT factor
    (50) factor_n -> . factor
    (45) factor -> . ID
    (46) factor -> . NUMBER
    (47) factor -> . brac_expr
    (48) factor -> . func_call
    (30) brac_expr -> . OPEN_BRACKET expr CLOSE_BRACKET
    (20) func_call -> . ID OPEN_BRACKET factors_n CLOSE_BRACKET

    NOT             shift and go to state 34
    ID              shift and go to state 32
    NUMBER          shift and go to state 36
    OPEN_BRACKET    shift and go to state 39

    factor_n                       shift and go to state 99
    factor                         shift and go to state 35
    brac_expr                      shift and go to state 37
    func_call                      shift and go to state 38

state 98

    (27) else_stat -> ELSE THEN lines . END
    (4) lines -> lines . line
    (6) line -> . var_decl
    (7) line -> . var_assign
    (8) line -> . if_stat
    (9) line -> . comment
    (10) line -> . print
    (11) line -> . loop
    (12) line -> . func_decl
    (16) var_decl -> . type ID ASSIGN factor_n ENDLINE
    (17) var_assign -> . ID ASSIGN factor_n ENDLINE
    (24) if_stat -> . IF OPEN_BRACKET expr CLOSE_BRACKET THEN lines end_if
    (2) comment -> . COMMENT
    (14) print -> . PRINT OPEN_BRACKET expr CLOSE_BRACKET ENDLINE
    (13) loop -> . LOOP OPEN_BRACKET expr CLOSE_BRACKET BEGIN lines END
    (15) func_decl -> . FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n
    (18) type -> . INT
    (19) type -> . STRING

    END             shift and go to state 100
    ID              shift and go to state 15
    IF              shift and go to state 16
    COMMENT         shift and go to state 17
    PRINT           shift and go to state 18
    LOOP            shift and go to state 19
    FUNCTION        shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22

    line                           shift and go to state 24
    var_decl                       shift and go to state 7
    var_assign                     shift and go to state 8
    if_stat                        shift and go to state 9
    comment                        shift and go to state 10
    print                          shift and go to state 11
    loop                           shift and go to state 12
    func_decl                      shift and go to state 13
    type                           shift and go to state 14

state 99

    (15) func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n .

    END             reduce using rule 15 (func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n .)
    ID              reduce using rule 15 (func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n .)
    IF              reduce using rule 15 (func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n .)
    COMMENT         reduce using rule 15 (func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n .)
    PRINT           reduce using rule 15 (func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n .)
    LOOP            reduce using rule 15 (func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n .)
    FUNCTION        reduce using rule 15 (func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n .)
    INT             reduce using rule 15 (func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n .)
    STRING          reduce using rule 15 (func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n .)
    ELSE            reduce using rule 15 (func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n .)
    RETURN          reduce using rule 15 (func_decl -> FUNCTION ID OPEN_BRACKET args CLOSE_BRACKET BEGIN lines RETURN factor_n .)


state 100

    (27) else_stat -> ELSE THEN lines END .

    END             reduce using rule 27 (else_stat -> ELSE THEN lines END .)
    ID              reduce using rule 27 (else_stat -> ELSE THEN lines END .)
    IF              reduce using rule 27 (else_stat -> ELSE THEN lines END .)
    COMMENT         reduce using rule 27 (else_stat -> ELSE THEN lines END .)
    PRINT           reduce using rule 27 (else_stat -> ELSE THEN lines END .)
    LOOP            reduce using rule 27 (else_stat -> ELSE THEN lines END .)
    FUNCTION        reduce using rule 27 (else_stat -> ELSE THEN lines END .)
    INT             reduce using rule 27 (else_stat -> ELSE THEN lines END .)
    STRING          reduce using rule 27 (else_stat -> ELSE THEN lines END .)
    ELSE            reduce using rule 27 (else_stat -> ELSE THEN lines END .)
    RETURN          reduce using rule 27 (else_stat -> ELSE THEN lines END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for OPEN_BRACKET in state 32 resolved as shift
